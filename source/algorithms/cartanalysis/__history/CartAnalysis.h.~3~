// Description: Performs cartometric analysis (i.e. detection of the cartographic projection)

// Copyright (c) 2010 - 2011
// Tomas Bayer
// Charles University in Prague, Faculty of Science
// bayertom@natur.cuni.cz

// This library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this library. If not, see <http://www.gnu.org/licenses/>.

#ifndef CartAnalysis_H
#define CartAnalysis_H

#include "libalgo/source/structures/graph/GraphM.h"
#include "libalgo/source/structures/list/Container.h"

//Forward declarations
template <typename T >
class Node3DCartesian;

template <typename T >
class Node3DCartesianProjected;

template <typename T >
class Point3DGeographic;

template <typename T>
class Projection;

template <typename T>
class ProjectionLimits;

template <typename T >
class Sample;

template <typename T >
struct TRansacResults;

template <typename T >
struct TMeridiansList;

template <typename T >
struct TParallelsList;

class sortSamplesByAllRatios;


//Result of absolute analysis will be matched using circle or Tissot indikatrix
typedef enum
{
        MatchCircle, MatchTissotIndikatrix
} TMatchPointsType;


//Parametrs of the analysis get from the command line
struct TAnalysisParameters
{
        //Internal structure: Information which cartometric analysis will be performed
        struct TAnalysisType
        {
                //Switches for analysis
                bool a_cnd, a_and, a_homt, a_helt, a_gn_ad, a_gn_tf, a_nnng, a_sig, a_vd_al, a_vd_tf, a_vd_tar, a_vd_id;

                TAnalysisType () :  a_cnd ( false ), a_and ( false ), a_homt ( false ), a_helt ( false ), a_gn_ad ( false ),
                        a_gn_tf ( false ), a_nnng ( false ), a_sig ( false ), a_vd_al ( false ), a_vd_tf ( false ),
                        a_vd_tar ( false ), a_vd_id ( false )  {}

                TAnalysisType ( const bool status ) :  a_cnd ( status ), a_and ( status ), a_homt ( status ), a_helt ( status ), a_gn_ad ( status ),
                        a_gn_tf ( status ), a_nnng ( status ), a_sig ( status ), a_vd_al ( status ), a_vd_tf ( status ), a_vd_tar ( status ),
                        a_vd_id ( status ) {}
        };

        //Analysis type
        TAnalysisType analysis_type;

        //Compare results to circle or Tissot indikatrix
        TMatchPointsType match_method;

        //Switches
        bool perform_heuristic, analyze_oblique_position, print_exceptions;

        //Total printed results
        unsigned short printed_results, analysis_repeat;

        //Parameters of the analysis: steps, increments, intervals and sensitivity
        double  latp_step, lonp_step, lat0_step, analyzed_proj_latp, analyzed_proj_lonp,
        analyzed_proj_lat0, heuristic_sensitivity_ratio, heuristic_sensitivity_increment;

        //Test and reference file
        char * test_file, *reference_file;

        //Analyzed projection, if set
        ProjectionLimits <double> * analyzed_proj;

        TAnalysisParameters () : analysis_type ( false ), match_method ( MatchTissotIndikatrix ), analyze_oblique_position ( false ),
                print_exceptions ( false ), printed_results ( 20 ), analysis_repeat ( 0 ), latp_step ( 10.0 ), lonp_step ( 10.0 ),
                lat0_step ( 10.0 ), analyzed_proj_latp ( 90.0 ), analyzed_proj_lonp ( 0.0 ), analyzed_proj_lat0 ( 0.0 ),
                heuristic_sensitivity_ratio ( 1.0 ), heuristic_sensitivity_increment ( 2.0 ), test_file ( NULL ), reference_file ( NULL ),
                analyzed_proj ( NULL ) { }
};


//Cartometric analysis
class CartAnalysis
{
        public:
                template <typename T>
                static void computeAnalysisForAllSamples ( Container <Sample <T> > *sl, Container <Projection <T> *> *pl, Container <Node3DCartesian <T> *> *nl_test, Container <Point3DGeographic <T> *> *pl_reference,
                                typename TMeridiansList <T> ::Type * meridians, typename TParallelsList <T> ::Type * parallels, const Container <Face <T> *> *faces_test, const GraphM <T> &g_test_nnn_graph, const GraphM <T> &g_test_sphere_of_influence_graph,
                                TAnalysisParameters & analysis_parameters, unsigned int & total_created_samples, const bool print_exception = true, std::ostream * output = &std::cout );

                template <typename T>
                static void printResults ( const Container <Sample <T> > *sl, unsigned int items_printed, const TAnalysisParameters & analysis_parameters, std::ostream * output = &std::cout );

                template <typename T>
                static void sortSamplesByComputedRatios ( Container <Sample <T> > *sl, const TAnalysisParameters::TAnalysisType & analysis_type );

                template <typename T>
                static void setPositionForSortedSamples ( Container <Sample <T> > *sl, const unsigned short index );

                template <typename T>
                static bool checkSample ( const typename TMeridiansList <T> ::Type * meridians, const typename TParallelsList <T> ::Type * parallels, const Container <Node3DCartesian <T> *> *nl_test,
                                          const Container <Node3DCartesianProjected <T> *> *nl_projected, Container <Node3DCartesian <T> *> *nl_transformed, const T treshold = 0.5 );

                template <typename T>
                static void analyzeSampleCrossNearestNeighbourDistance ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test, const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                                Container <Node3DCartesian <T> *> *nl_transformed );

                template <typename T>
                static void analyzeSampleAverageNearestNeighbourDistance ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                                Container <Node3DCartesian <T> *> *nl_transformed );

                template <typename T>
                static void analyzeSampleHomotheticTransformationDeviation ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test, const  Container <Node3DCartesianProjected  <T> *> *nl_projected,
                                Container <Node3DCartesian <T> *> *nl_transformed, TMatchPointsType & match_type = MatchCircle );

                template <typename T>
                static void analyzeSampleHelmertTransformationDeviation ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test, const  Container <Node3DCartesianProjected  <T> *> *nl_projected,
                                Container <Node3DCartesian <T> *> *nl_transformed, TMatchPointsType & match_type = MatchCircle );

                template <typename T>
                static void analyzeSampleGeographicNetworkAngularDifference ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                                const typename TMeridiansList <T> ::Type * meridians, const typename TParallelsList <T> ::Type * parallels );

                template <typename T>
                static void analyzeSampleGeographicNetworkTangentFunctionRatio ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                                const typename TMeridiansList <T> ::Type * meridians, const typename TParallelsList <T> ::Type * parallels );

                template <typename T>
                static void analyzeSampleKNNGraphRatio ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                                const GraphM <T> &g_test, const unsigned int k, const bool print_exception );

                template <typename T>
                static void analyzeSampleNNNGraphRatio ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                                const GraphM <T> &g_test, TAnalysisParameters::TAnalysisType & analysis, const bool print_exception );


                template <typename T>
                static void analyzeSampleSphereOfInfulenceGraphRatio ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                                const GraphM <T> &g_test, TAnalysisParameters::TAnalysisType & analysis, const bool print_exception );

                template <typename T>
                static void analyzeSampleUsingVoronoiDiagramRatio ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test, const Container <Node3DCartesianProjected  <T> *> *nl_projected, const Container <Face <T> *> *faces_test,
                                const GraphM <T> &g_test_nnn_graph, TAnalysisParameters::TAnalysisType & analysis, const bool print_exception, std::ostream * output = &std::cout );


        private:

                template <typename T>
                static void computeAnalysisForOneSample ( Container <Sample <T> > *sl, Container <Projection <T> *> *pl, Container <Node3DCartesian <T> *> *nl_test, Container <Point3DGeographic <T> *> *pl_reference, typename TMeridiansList <T> ::Type * meridians, typename TParallelsList <T> ::Type * parallels,
                                const Container <Face <T> *> *faces_test, const GraphM <T> &g_test_nnn_graph, const GraphM <T> &g_test_sphere_of_influence_graph, const Projection <T> *proj, const T latp, const T lonp, const T lat0, TAnalysisParameters & analysis_parameters,
                                unsigned int & created_samples_projection, unsigned int & total_created_samples, const bool print_exception );

};

#include "CartAnalysis.hpp"

#endif
