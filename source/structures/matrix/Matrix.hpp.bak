// Description: Matrix and basic operators

// Copyright (c) 2010 - 2012
// Tomas Bayer
// Charles University in Prague, Faculty of Science
// bayertom@natur.cuni.cz

// This library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this library. If not, see <http://www.gnu.org/licenses/>.


#ifndef Matrix_HPP
#define Matrix_HPP

//#include "Matrix.h"

#include "libalgo/source/const/Const.h"

#include "libalgo/source/exceptions/ErrorBadData.h"
#include "libalgo/source/exceptions/ErrorIndexOutOfBound.h"
#include "libalgo/source/exceptions/ErrorMathMatrixDifferentSize.h"


//Constructor of the matrix
template <typename T>
Matrix <T> :: Matrix ( unsigned int m_rows, unsigned int n_columns, const T item, const T eye ) :
        rows_count ( m_rows ), columns_count ( n_columns ), items ( m_rows, std::vector <T> ( n_columns, item ) )
{
        //Create natrix with eye value on main diagonal
        for ( unsigned int i = 0; i < rows_count; i++ )
        {
                items[i][i] = eye;
        }
}


//Copy constructor
template <typename T>
//template <typename U>
Matrix <T> :: Matrix ( const Matrix <T> &M )
        : rows_count ( M.rows() ), columns_count ( M.cols() ), items ()
{
        //Create copy of the matrix
        for ( unsigned int i = 0; i < M.getItems().size(); i++ )
        {
                items.push_back ( std::vector <T> ( M.getItems() [i].begin(), M.getItems() [i].end() ) );
        }
}


//Destructor
template <typename T>
Matrix <T> :: ~Matrix() {}


//Assignment operator = ( Matrix x Matrix )
template <typename T>
Matrix <T> & Matrix <T> ::operator = ( const Matrix <T> &M )
{
        if ( this != &M )
        {

                //Matrix dimemension are invalid, throw exception
                if ( rows_count !=  M.rows_count )
                {
                        throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " different rows_count count in operator =. Can not assign matrices, (m=, n=):  ", rows_count, columns_count, M.rows(), M.cols() );
                }

                //Matrix dimemension are invalid, throw exception
                if ( columns_count != M.columns_count )
                {
                        throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " different columns_count count in operator =. Can not assign matrices.  ", this->rows_count, this->columns_count, M.rows(), M.cols() );
                }

                //Process all lines
                for ( unsigned int i = 0; i < rows_count; i++ )
                {
                        //Process columns_count of the actual row
                        for ( unsigned int j = 0 ; j < columns_count; j++ )
                        {
                                //Add to vector
                                items[i][j] = M.items[i][j];
                        }
                }
        }

        return *this;
}


//Assignment operator = ( Matrix x number )
template <typename T>
//template <typename U>
T & Matrix <T> ::operator = ( const Matrix <T> &M )
{
        const unsigned int m = M.rows(), n = M.cols();

        //Matrix dimemension are invalid, throw exception
        if ( ( m != 1 ) || ( n != 1 ) )
        {
                throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " invalis matrix dimensions, m != 1  or n !=1. Can not assign matrix to the scalar.  ", rows_count, columns_count, M.rows(), M.cols() );
        }

        //Return item
        return M.items[0][0];
}


//Assignment operator = ( Matrix x Matrix )
template <typename T>
//template <typename U>
Matrix <T> & Matrix <T> ::operator = ( const T & item )
{
        //Create temporary matrix
        Matrix <T> C ( 1, 1 );

        //Set item to the matrix
        C ( 0, 0 ) = item;

        return C;
}


//Operators +: Matrix + Matrix
template <typename T>
//template <typename U>
Matrix <T> & Matrix <T> :: operator + ( const Matrix <T> &M ) const
{
        return Matrix <T> ( *this ).operator += ( M );
}


//Operators +: Matrix(1, 1) + Scalar
template <typename T>
//template <typename U>
Matrix <T> & Matrix <T> :: operator + ( const T & val ) const
{
        return Matrix <T> ( *this ).operator += ( val );
}


//Operators +: Scalar + Matrix(0, 0)
template <typename T>
//template <typename U>
T & Matrix <T> :: operator + ( const Matrix <T> &M ) const
{
        return Matrix <T> ( *this ).operator += ( M );

}


//Matrix operators - : Matrix - Matrix
template <typename T>
//template <typename U>
Matrix<T> & Matrix <T> :: operator - ( const Matrix < T > &M ) const
{
        return Matrix < T > ( *this ).operator -= ( M );
}


//Matrix operators - : Matrix(1, 1) - scalar
template <typename T>
//template <typename U>
Matrix<T> & Matrix <T> :: operator - ( const T & val ) const
{
        return Matrix < T > ( *this ).operator -= ( val );
}


//Matrix operators - : Scalar - Matrix(1, 1)
template <typename T>
//template <typename U>
T & Matrix <T> :: operator - ( const Matrix <T> &M ) const
{
        return Matrix < T > ( *this ).operator -= ( M );
}


//Matrix  operators += : Matrix + Matrix
template <typename T>
//template <typename U>
Matrix <T> & Matrix <T> :: operator += ( const Matrix <T> &M )
{
        //Matrix dimemension are invalid, throw exception
        if ( this->rows_count !=  M.rows() )
        {
                throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " different rows_count count.  Cannot compute A += B. " , rows_count, columns_count, M.rows(), M.cols() );
        }

        //Matrix dimemension are invalid, throw exception
        if ( this->columns_count != M.cols() )
        {
                throw ErrorMathMatrixDifferentSize ( "ErrorMathRange: ", " different columns_count count.  Cannot compute A += B. ", rows_count, columns_count, M.rows(), M.cols() );
        }

        //Process all lines
        for ( unsigned int i = 0;  i < rows_count; i++ )
        {
                //Process columns_count of the actual row
                for ( unsigned int j = 0 ; j < columns_count; j++ )
                {
                        //Add to vector
                        items[i][j] = items[i][j]  + M ( i, j );
                }
        }

        return *this;
}


//Matrix  operators += : Matrix (1, 1) + Scalar
template <typename T>
//template <typename U>
Matrix <T> & Matrix <T> :: operator += ( const T & val )
{
        //Matrix dimemension are invalid, throw exception
        if ( ( this->rows_count !=  1 ) || ( this->columns_count != 1 ) )
        {
                throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " different rows_count count.  Cannot compute A += B. " , rows_count, columns_count, this->rows_count, this->columns_count );
        }

        items[0][0] = items[0][0] + val;

        return *this;
}

/*
//Matrix operators += : Scalar + Matrix(1, 1)
template <typename T>
template <typename U>
U & Matrix <T> :: operator += ( const Matrix <T> &M ) const
{
        //Matrix dimemension are invalid, throw exception
        if ( ( this->rows_count !=  1 ) || ( this->columns_count != 1 ) )
        {
                throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " different rows_count count.  Cannot compute A += B. " , rows_count, columns_count, M.rows(), M.cols() );
        }

        return items[0][0] + val;
}
*/

//Matrix  operators -= : Matrix - Matrix
template <typename T>
//template <typename U>
Matrix <T> & Matrix <T> :: operator -= ( const Matrix <T> &M )
{
        //Matrix dimemension invalid, throw exception
        if ( rows_count !=  M.rows() )
        {
                throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " different rows_count count. Cannot compute A -= B.", rows_count, columns_count, M.rows(), M.cols() );
        }

        //Matrix dimemension invalid, throw exception
        if ( columns_count != M.cols() )
        {
                throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " different columns_count count.  Cannot compute A -= B. ", rows_count, columns_count, M.rows(), M.cols() );
        }

        //Process all lines
        for ( unsigned int i = 0; i < rows_count; i++ )
        {
                //Process columns_count of the actual row
                for ( unsigned int j = 0 ; j < columns_count; j++ )
                {
                        //Add to vector
                        items[i][j] = items[i][j] - M ( i, j );
                }
        }

        return *this;
}


//Matrix  operators -= : Matrix (1, 1) - Scalar
template <typename T>
//template <typename U>
Matrix <T> & Matrix <T> :: operator -= ( const T & val )
{
        //Matrix dimemension are invalid, throw exception
        if ( ( this->rows_count !=  1 ) || ( this->columns_count != 1 ) )
        {
                throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " different rows_count count.  Cannot compute A += B. " , rows_count, columns_count, this->rows_count, this->columns_count );
        }

        items[0][0] = items[0][0] - val;

        return *this;
}

/*
//Matrix operators -= : Scalar - Matrix(1, 1)
template <typename T>
template <typename U>
U & Matrix <T> :: operator -= ( const Matrix <T> &M ) const
{
        //Matrix dimemension are invalid, throw exception
        if ( ( this->rows_count !=  1 ) || ( this->columns_count != 1 ) )
        {
                throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " different rows_count count.  Cannot compute A += B. " , rows_count, columns_count, M.rows(), M.cols() );
        }

        return M ( 0, 0 ) + val;
}
*/

//Matrix  operator * : Matrix x Matrix
template <typename T>
//template <typename U>
Matrix <T> Matrix <T> ::operator * ( const Matrix <T> &M ) const
{
        //Matrix * Matrix
        const unsigned int m2 = M.rows(), n2 = M.cols();

        //Matrix dimemension invalid, throw exception
        if ( columns_count !=  m2 )
        {
                throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " different rows_count count. Cannot compute A *= B. ", this->rows_count, this->columns_count, M.rows(), M.cols() );
        }

        //Create temporary matrix
        Matrix <T> C ( rows_count, n2 );

        //Multiplication of matrices
        for ( unsigned int i = 0; i < rows_count; i++ )
        {
                for ( unsigned int j = 0; j < n2; j++ )
                {
                        T sum = 0;

                        for ( unsigned int k = 0; k < columns_count; k++ )
                        {
                                sum += items[i][k] * M ( k, j );
                        }

                        C ( i, j ) = sum;
                }
        }

        return C;
}


//Matrix  operator *: Matrix x Scalar
template <typename T>
//template <typename U>
Matrix <T> Matrix <T> ::operator * ( const T & val ) const
{
        //Create temporary matrix
        Matrix <T> C ( rows_count, columns_count );

        //Multiplication of matrices
        for ( unsigned int i = 0; i < rows_count; i++ )
        {
                for ( unsigned int j = 0; j < columns_count; j++ )
                {
                        C ( i, j ) = val * items[i][j];
                }
        }

        return C;
}


//Matrix  operator *: Matrix (1, 1) x scalar
template <typename T>
//template <typename U>
T & Matrix <T> ::operator * ( const T & val ) const
{
        //Matrix dimemension are invalid, throw exception
        if ( ( this->rows_count !=  1 ) || ( this->columns_count != 1 ) )
        {
                throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " different rows_count count.  Cannot compute A += B. " , rows_count, columns_count, this->rows_count, this->columns_count );
        }

        return items[0][0] * val;
}

/*
//Matrix  operator *: Scalar x Matrix(1,1)
template <typename T>
template <typename U>
U & Matrix <T> ::operator * ( const Matrix <U> &M ) const
{
        //Matrix dimemension are invalid, throw exception
        if ( ( M.rows() !=  1 ) || ( M.columns() != 1 ) )
        {
                throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " different rows_count count.  Cannot compute A += B. " , rows_count, columns_count, M.rows(), M.cols() );
        }

        return M ( 0, 0 ) * val;
}
*/

//Matrix  operator /: Matrix / Scalar
template <typename T>
//template <typename U>
Matrix <T> Matrix <T> ::operator / ( const T & val ) const
{
        //Create temporary matrix
        Matrix <T> C ( rows_count, columns_count );

        //Divider is zero
        if ( val < MIN_FLOAT )
        {
                throw ErrorMathZeroDevision ( "ErrorMathZeroDevision: can not divide matrix by scalar, val=  ", val );
        }

        //Multiplication of matrices
        for ( unsigned int i = 0; i < rows_count; i++ )
        {
                for ( unsigned int j = 0; j < columns_count; j++ )
                {
                        C ( i, j ) = items[i][j] / val;
                }
        }

        return C;
}


//Matrix  operator /: Matrix (1, 1) x scalar
template <typename T>
//template <typename U>
T & Matrix <T> ::operator / ( const T & val ) const
{
        //Matrix dimemension are invalid, throw exception
        if ( ( this->rows_count !=  1 ) || ( this->columns_count != 1 ) )
        {
                throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " different rows_count count.  Cannot compute A += B. " , rows_count, columns_count, this->rows_count, this->columns_count );
        }

        //Divider is zero
        if ( val < MIN_FLOAT )
        {
                throw ErrorMathZeroDevision ( "ErrorMathZeroDevision: can not divide matrix by scalar, val=  ", val );
        }

        return items[0][0] / val;
}

/*
//Matrix  operator /: Scalar / Matrix(1,1)
template <typename T>
template <typename U>
U & Matrix <T> ::operator / ( const Matrix <U> &M ) const
{
        //Matrix dimemension are invalid, throw exception
        if ( ( M.rows() !=  1 ) || ( M.columns() != 1 ) )
        {
                throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " different rows_count count.  Cannot compute A += B. " , rows_count, columns_count, M.rows(), M.cols() );
        }

        //Divider is zero
        if ( val < MIN_FLOAT )
        {
                throw ErrorMathZeroDevision ( "ErrorMathZeroDevision: can not divide matrix by scalar, val=  ", val );
        }

        return M ( 0, 0 ) * val;
}
*/

template <typename T>
//template <typename U>
Matrix <T> Matrix <T> ::operator % ( const T & val ) const
{
        // Matrix % scalar (modulo)

        //Create temporary matrix
        Matrix <T> C ( rows_count, columns_count );

        //Multiplication of matrices
        for ( unsigned int i = 0; i < rows_count; i++ )
        {
                for ( unsigned int j = 0; j < columns_count; j++ )
                {
                        C ( i, j ) = fmod ( items[i][j], val );
                }
        }

        return C;
}



template <typename T>
//template <typename U>
Matrix <T> & Matrix <T>:: operator *= ( const Matrix <T> &M )
{
        //Matrix * Matrix
        return this = this * M;
}


template <typename T>
template <typename U>
Matrix <T> Matrix <T> ::operator | ( const Matrix <U> &M ) const
{
        //Hadamard product (dot product .*)
        const unsigned int m2 = M.rows(), n2 = M.cols();

        //Matrix dimemension invalid, throw exception
        if ( rows_count !=  m2 )
        {
                throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " different rows_count count. Cannot compute A .* B.", rows_count, columns_count, M.rows(), M.cols() );
        }

        //Matrix dimemension invalid, throw exception
        if ( columns_count != n2 )
        {
                throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " different columns_count count.  Cannot compute A .* B. ", rows_count, columns_count, M.rows(), M.cols() );
        }

        //Create temporary matrix
        Matrix <T> C ( M );

        //Hadamard product
        for ( unsigned int i = 0; i < rows_count; i++ )
        {
                for ( unsigned int j = 0; j < columns_count; j++ )
                {
                        C ( i, j ) = items[i][j] * M ( i, j );
                }
        }

        return C;

}


//Get row / col
template <typename T>
Matrix <T> Matrix <T> ::row ( unsigned int r ) const
{

        //Matrix dimemension invalid, throw exception
        if ( r > rows_count )
        {
                throw ErrorIndexOutOfBound ( "ErrorIndexOutOfBound: ", " row index exceeds rows_count.  " );
        }

        //Create empty matrix
        Matrix <T> m_temp ( 1, columns_count );

        //Copy items to the matrix
        for ( unsigned int i = 0; i < columns_count; i++ )
        {
                m_temp ( 0, i ) =  items[r][i];
        }

        //Get matrix
        return m_temp;
}


template <typename T>
Matrix < T > Matrix <T> :: col ( unsigned int c ) const
{
        //Matrix dimemension invalid, throw exception
        if ( c > columns_count )
        {
                throw ErrorIndexOutOfBound ( "ErrorIndexOutOfBound: ", " col index exceeds columns_count.  " );
        }

        //Create temporary matrix
        Matrix <T> m_temp ( rows_count, 1 );

        //Copy items to the matrix
        for ( unsigned int i = 0; i < rows_count; i++ )
        {
                m_temp ( i, 0 ) = items[i][c];
        }

        //Get matrix
        return m_temp;
}


//Set row / col
template <typename T>
void Matrix <T> ::row ( const Matrix <T> &M, const unsigned int r )
{
        //Matrix dimemension invalid, throw exception
        if ( r > rows_count )
        {
                throw ErrorIndexOutOfBound ( "ErrorIndexOutOfBound: ", " row index exceeds rows_count.  " );
        }

        //Matrix dimemension invalid, throw exception
        if ( M.cols() != columns_count )
        {
                throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " invalid dimension of the matrices (columns_count count).  ", this->rows_count, this->columns_count, M.rows(), M.cols() );
        }

        //Copy row
        for ( unsigned int i = 0; i < columns_count; i++ )
        {
                items[r][i] = M ( 0, i );
        }
}


//Set submatrix
template <typename T>
void Matrix <T> ::col ( const Matrix <T> &M, const unsigned int c )
{
        //Matrix dimemension invalid, throw exception
        if ( c > columns_count )
        {
                throw ErrorIndexOutOfBound ( "ErrorIndexOutOfBound: ", " col index exceeds columns_count.  " );
        }

        //Matrix dimemension are invalid, throw exception
        if ( M.rows() != rows_count )
        {
                throw ErrorMathMatrixDifferentSize ( "ErrorMathMatrixDifferentSize: ", " invalid dimension of the matrices (rows_count count).  ", this->rows_count, this->columns_count, M.rows(), M.cols() );
        }

        //Copy col
        for ( unsigned int i = 0; i < rows_count; i++ )
        {
                items[i][c] = M ( i, 0 );
        }
}


template <typename T>
void Matrix <T> ::submat ( const Matrix <T> & M, const unsigned int row, const unsigned int col )
{
        const unsigned int m = M.rows(), n = M.cols();

        if ( m + row > rows_count )
        {
                throw ErrorIndexOutOfBound ( "ErrorIndexOutOfBound: a submatrix does not fit at the specified row position, ", "can not append a submatrix to the matrix. " );
        }

        if ( n + col > columns_count )
        {
                throw ErrorIndexOutOfBound ( "ErrorIndexOutOfBound: a submatrix does not fit at the specified col position, ", "can not append a submatrix to the matrix." );
        }

        //Copy submatrix
        for ( unsigned int i = 0; i < m; i++ )
        {
                for ( unsigned int j = 0; j < n; j++ )
                {
                        items [i+row][j+col] = M ( i, j );
                }
        }

}



//Matrix operator ()()
template <typename T>
T & Matrix <T> :: operator() ( const unsigned int row, unsigned int col )
{
        //Matrix dimemension invalid, throw exception
        if ( row >= rows_count )
        {
                throw ErrorIndexOutOfBound ( "ErrorIndexOutOfBound: ", "invalid dimension of the matrix (row > rows_count), row = " );
        }

        //Matrix dimemension are invalid, throw exception
        if ( col >= columns_count )
        {
                throw ErrorIndexOutOfBound ( "ErrorIndexOutOfBound: ", "invalid dimension of the matrix (col > columns_count), col = " );
        }

        return items[row][col];
}


//Matrix operator ()()
template <typename T>
T const & Matrix <T> :: operator() ( const unsigned int row, unsigned int col ) const
{
        //Matrix dimemension are invalid, throw exception
        if ( row >= rows_count )
        {
                throw ErrorIndexOutOfBound ( "ErrorIndexOutOfBound: ", "invalid dimension of the matrix (row > rows_count), row = " );
        }

        //Matrix dimemension are invalid, throw exception
        if ( col >= columns_count )
        {
                throw ErrorIndexOutOfBound ( "ErrorIndexOutOfBound: ", "invalid dimension of the matrix (col > columns_count), col = " );
        }

        return items[row][col];
}


//Matrix operator (r1, r2, c1, c2): get submatrix of the matrix
template <typename T>
Matrix <T>  Matrix <T> ::operator () ( const unsigned int r1, const unsigned int r2, const unsigned int c1, const unsigned int c2 ) const
{
        //Bad row index
        if ( r2 >  rows_count )
                throw ErrorBadData ( "ErrorBadData: row index r2 must not be greater than A.rows_count. ", " Can not create the submatrix. " );

        //Bad row index
        if ( c2 > columns_count )
                throw ErrorBadData ( "ErrorBadData: col index c2 must not be greater than A.columns_count. ", " Can not create the submatrix. " );

        //Bad row index interval
        if ( r1 > r2 )
                throw ErrorBadData ( "ErrorBadData: row index r2 must not be smaller then r1. ", " Can not create the submatrix. " );

        //Bad col index interval
        if ( c1 > c2 )
                throw ErrorBadData ( "ErrorBadData: col index c2 must not be smaller then c1. ", " Can not create the submatrix. " );

        //Create sub-matrix
        Matrix <T> M ( r2 - r1 + 1, c2 - c1 + 1 ) ;

        for ( unsigned int i = 0; i < ( r2 - r1 + 1 ); i++ )
        {
                for ( unsigned int j = 0; j < ( c2 - c1 + 1 ); j++ )
                {
                        M ( i, j ) = items[i +r1 ][j + c1];
                }
        }

        return M;
}


template <typename T>
void Matrix <T> ::print ( std::ostream * output ) const
{
        //Print matrix
        *output << std::showpoint << std::fixed << std::right;
        *output << '\n';

        for ( unsigned int i = 0; i < rows_count; i++ )
        {
                *output << "| ";

                for ( unsigned int j = 0; j < columns_count; j++ )
                {
                        *output <<  std::setw ( 11 ) << std::setprecision ( 2 );
                        items[i][j] < MAX_FLOAT ? *output << items[i][j] : *output << "---";
                }

                *output << " |" << '\n';
        }
}


#endif
