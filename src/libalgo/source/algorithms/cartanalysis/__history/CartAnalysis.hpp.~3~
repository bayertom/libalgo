// Description: Performs cartometric analysis (i.e. detection of the cartographic projection)

// Copyright (c) 2010 - 2011
// Tomas Bayer
// Charles University in Prague, Faculty of Science
// bayertom@natur.cuni.cz

// This library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this library. If not, see <http://www.gnu.org/licenses/>.


#ifndef CartAnalysis_HPP
#define CartAnalysis_HPP

#include <algorithm>
#include <iomanip>
#include <cmath>


#include "libalgo/source/const/Const.h"

#include "libalgo/source/structures/point/Node3DCartesianProjected.h"
#include "libalgo/source/structures/projection/Sample.h"

#include "libalgo/source/algorithms/carttransformation/CartTransformation.h"
#include "libalgo/source/algorithms/transformation/Helmert.h"
#include "libalgo/source/algorithms/angle3points/Angle3Points.h"
#include "libalgo/source/algorithms/facearea/FaceArea.h"

#include "libalgo/source/algorithms/tangentfunction/TangentFunction.h"
#include "libalgo/source/algorithms/innerdistance/InnerDistance.h"
#include "libalgo/source/algorithms/nndistance/NNDistance.h"
#include "libalgo/source/algorithms/tarcriterion/TARCriterion.h"
#include "libalgo/source/algorithms/voronoi2D/Voronoi2D.h"

#include "libalgo/source/io/DXFExport.h"

#include "libalgo/source/comparators/sortPointsByID.h"
#include "libalgo/source/comparators/sortPointsByX.h"

#include "libalgo/source/comparators/sortSamplesByCrossNearestNeighbourDistanceRatio.h"
#include "libalgo/source/comparators/sortSamplesByAverageNearestNeighbourDistanceRatio.h"
#include "libalgo/source/comparators/sortSamplesBySimilarityTransformationRatio.h"
#include "libalgo/source/comparators/sortSamplesByAngularDifferencesRatio.h"
#include "libalgo/source/comparators/sortSamplesByTangentFunctionRatio.h"
#include "libalgo/source/comparators/sortSamplesByNNNGraphRatio.h"
#include "libalgo/source/comparators/sortSamplesBySphereOfInfluenceGraphRatio.h"
#include "libalgo/source/comparators/sortSamplesByVoronoiCellAreaLengthRatio.h"
#include "libalgo/source/comparators/sortSamplesByVoronoiCellTangentFunctionRatio.h"
#include "libalgo/source/comparators/sortSamplesByVoronoiCellTARRatio.h"
#include "libalgo/source/comparators/sortSamplesByVoronoiCellInnerDistanceRatio.h"
#include "libalgo/source/comparators/sortSamplesByAllRatios.h"

#include "libalgo/source/exceptions/ErrorMath.h"

//Set namespace
using namespace MatrixOperations;


template <typename T>
void CartAnalysis::ComputeAnalysisForAllSamples ( Container <Sample <T> *> *sl, Container <Projection <T> *> *pl, Container <Node3DCartesian <T> *> *nl_test, Container <Point3DGeographic <T> *> *pl_reference,
                typename TMeridiansList <T> ::Type * meridians, typename TParallelsList <T> ::Type * parallels, const Container <Face <T> *> *faces_test, const Projection <T> *analyzed_proj,
                TAnalysis & analysis, const T lat_step, const T lon_step, const T lat0_step, const bool analyze_oblique_position, unsigned int & total_created_samples, const bool print_exception, std::ostream * output )
{
        //Create list of cartographic samples for testing
        unsigned int created_samples_projection = 0;

        //Total samples ( successful and unsuccessful )
        total_created_samples = 0;

        //Create sample for analyzed projection and set flag for this sample
        if ( analyzed_proj != NULL )
        {
                ComputeAnalysisForOneSample ( sl, pl, nl_test, pl_reference, meridians, parallels, faces_test, analyzed_proj, analysis,
                                              analyzed_proj->getLatPole(), analyzed_proj->getLonPole(), analyzed_proj->getLat0(), created_samples_projection, total_created_samples, print_exception );

                if ( created_samples_projection > 0 ) ( *sl ) [0]->setAnalyzedProjectionSample ( true );
        }

        //Sample with analyzed projection had been created or there is no analyzed projection
        if ( ( analyzed_proj == NULL ) || ( analyzed_proj != NULL ) && ( created_samples_projection > 0 ) )
        {
                //Process  all projections
                for ( typename TItemsList <Projection <T> *> ::Type ::const_iterator i_projections = pl->begin(); i_projections != pl->end(); ++ i_projections )
                {
                        //Get limits of the cartographic pole latitude and longitude: some projections are defined only in normal position
                        created_samples_projection = 0;

                        //Print projection name
                        *output << ( *i_projections ) -> getProjectionName() << ": ";

			//Cast projection to projection limits: get projection limits
			const ProjectionLimits <T> *proj_limits = dynamic_cast <ProjectionLimits <T> *> (*i_projections );
                        
			//Process all meridians of the projection ( enable / disable analysis in oblique position )
                        //T latp = -90;
                        for ( T latp  = ( analyze_oblique_position ? ( proj_limits ) -> getLatPoleMin() : 90 );
                                        latp <= ( analyze_oblique_position ? ( proj_limits ) -> getLatPoleMax() : 90 ); latp += lat_step )
                        {
                                //T lonp = 0;
                                for ( T lonp = ( fabs ( latp ) == 90 ? 0 : ( proj_limits ) -> getLonPoleMin() ) ;
                                                 fabs ( latp ) == 90 ? lonp == 0 : lonp <= ( proj_limits ) -> getLonPoleMax();  lonp += lon_step )
                                {
                                        //T lat0 = 0;
                                        for ( T lat0 = ( proj_limits )-> getLat0Min(); lat0 <= ( proj_limits )-> getLat0Max(); lat0 += lat0_step )
                                        {
                                                //Create one sample
                                                ComputeAnalysisForOneSample ( sl, pl, nl_test, pl_reference, meridians, parallels, faces_test, *i_projections,
                                                                              analysis, latp, lonp, lat0, created_samples_projection, total_created_samples, print_exception );
                                        }
                                }
                        }

                        //Print samples count
                        *output << " [" << created_samples_projection << " created]" << std::endl;
                }
        }
}


template <typename T>
void CartAnalysis::ComputeAnalysisForOneSample ( Container <Sample <T> *> *sl, Container <Projection <T> *> *pl, Container <Node3DCartesian <T> *> *nl_test, Container <Point3DGeographic <T> *> *pl_reference, typename TMeridiansList <T> ::Type * meridians, typename TParallelsList <T> ::Type * parallels,
				const Container <Face <T> *> *faces_test, const Projection <T> *proj, TAnalysis & analysis, const T latp, const T lonp, const T lat0, unsigned int & created_samples_projection, unsigned int & total_created_samples, const bool print_exception, std::ostream * output )
{
        //Create one sample
        Sample <T> *sample = NULL;

        try
	{
                //Create empty list of projected points and transformed points
                Container <Node3DCartesianProjected <T> *> nl_projected;
                Container <Node3DCartesian <T> *> nl_transformed;

                //Compute coordinates of all geographic points points in sample's projection and add to the list
                for ( unsigned int i = 0; i < pl_reference->size(); i++ )
                {
                        T lat_trans = 0, lon_trans = 0;
                        nl_projected.push_back ( new Node3DCartesianProjected <T>
                                               ( CartTransformation::latLonToX ( proj->getXEquat(), ( *pl_reference ) [i]->getLat(), ( *pl_reference ) [i]->getLon(), lat_trans, lon_trans, proj->getR(), proj->getA(),
                                                                 proj->getB(), latp, lonp, proj->getDx(), proj->getDy(), lat0, proj->getLat1(), proj->getLat2(), proj->getLon0(), print_exception ),
                                                CartTransformation::latLonToY ( proj->getYEquat(), ( *pl_reference ) [i]->getLat(), ( *pl_reference ) [i]->getLon(), lat_trans, lon_trans, proj->getR(), proj->getA(),
                                                                 proj->getB(), latp, lonp, proj->getDx(), proj->getDy(), lat0, proj->getLat1(), proj->getLat2(), proj->getLon0(), print_exception ) ) );
                }

                //Compare shape of equator, meridian and north / south pole using tangent function (small heuristic, throw unsuable samples)
                if ( checkSample ( meridians, parallels, nl_test, &nl_projected ) )
                {
			
			//Set adjacent points for meridian/parallel in projected points using indices
                        typename TMeridiansList <T> ::Type :: iterator i_meridians = meridians->begin();
                        typename TParallelsList <T> ::Type :: iterator i_parallels = parallels->begin();

                        //Process all found meridians and parallels
                        for ( ; i_meridians != meridians->end(); ++ i_meridians )
                        {
                                ( * i_meridians ).setPointsIndicesInList ( & nl_projected );
                        }

			//Process all found parallels
                        for ( ;i_parallels != parallels->end(); ++ i_parallels )
			{
                                ( * i_parallels ).setPointsIndicesInList ( & nl_projected );
                        }

                        //Remove duplicate elements from reference data set (projected points)
                        nl_projected.removeDuplicateElements ( nl_projected.begin(), nl_projected.end(), sortPointsByX <Node3DCartesianProjected <T> *> (), isEqualPointByPlanarCoordinates <Node3DCartesianProjected <T> *> () );

                        //Do both datasets contain the same number of points?
                        if ( pl_reference->size() == nl_projected.size() )
                        {

                                //Create sample
                                sample = new Sample <T> ( proj->getProjectionName(), latp, lonp, lat0 );

                                //Compute all cartometric analysis
                                if ( analysis.a1 )
                                {
                                        analyzeSampleAverageNearestNeighbourDistance ( sample, nl_test, & nl_projected, &nl_transformed );
                                }

                                if ( analysis.a2 )
                                {
                                        analyzeSampleCrossNearestNeighbourDistance ( sample, nl_test, &nl_projected, &nl_transformed );
                                }

                                if ( analysis.a3 )
                                {
                                        analyzeSampleSimilaritytransformationDeviation ( sample, nl_test, &nl_projected, &nl_transformed );
                                }

                                if ( analysis.a4 )
                                {
                                        analyzeSampleGeographicNetworkAngularDifference ( sample, nl_test, &nl_projected, meridians, parallels );
                                }

                                if ( analysis.a5 )
                                {
                                        analyzeSampleGeographicNetworkTangentFunctionRatio ( sample, nl_test, &nl_projected, meridians, parallels );
                                }

                                if ( analysis.a6 )
                                {
                                        analyzeSampleNNNGraphRatio ( sample, nl_test, &nl_projected, &nl_transformed );
                                }

                                if ( analysis.a7 )
                                {
                                        analyzeSampleSphereOfInfulenceGraphRatio ( sample, nl_test, &nl_projected, &nl_transformed );
                                }

                                if ( analysis.a8 || analysis.a9 || analysis.a10 || analysis.a11 )
                                {
                                        analyzeSampleUsingVoronoiDiagramRatio ( sample, nl_test, &nl_projected, faces_test, analysis );
                                }

                                //Add sample to the samples list
                                sl->push_back ( sample );

                                //Increment created samples for projection
                                created_samples_projection ++;
                        }
                }
        }

        //Delete sample, math error, then continue in processing of other samples
        catch ( ErrorMath & error )
        {
             
                if ( sample != NULL )
                {
                        delete sample;
                        sample = NULL;
                }
        }

        //Delete sample, parse error, then continue in processing of samples
        catch ( ErrorParse & error )
        {
                if ( sample != NULL )
                {
                        delete sample;
                        sample = NULL;
                }
        }

        //Print "." for every 1000-th sample
        if ( total_created_samples % 1000 == 0 )
        {
                output->flush();
                *output << ".";
        }

        //Increment samples index
        total_created_samples ++;
}



template <typename T>
bool CartAnalysis::checkSample ( const typename TMeridiansList <T> ::Type * meridians, const typename TParallelsList <T> ::Type * parallels, const Container <Node3DCartesian <T> *> *nl_test, const Container <Node3DCartesianProjected <T> *> *nl_projected, const T similarity_ratio )
{
        //Small heuristic for sample: compare shape or the prime meridian, equator, nort pole and south pole for test and reference points

        //Process all meridians
        for ( typename TMeridiansList <T> ::Type::const_iterator i_meridians = meridians->begin(); i_meridians != meridians->end(); ++ i_meridians )
        {
                //Find prime meridian
                if ( ( *i_meridians ).getLongitude() == 0 )
                {
                        //Convert test meridian to Points 2D list
                        Container <Point3DCartesian <T> > pl_meridian_test ( nl_test, & ( ( * i_meridians ).getPointsIndices () ) );

                        //Convert projected meridian to Points2D list
                        Container <Point3DCartesian <T> > pl_meridian_projected ( nl_projected,  & ( ( * i_meridians ).getPointsIndices () ) );

                        //Compute tangent function difference for each test and projected meridian
                        T tangent_function_ratio_prime_meridian = TangentFunction::compare2PolyLinesUsingTangentFunction ( &pl_meridian_test, &pl_meridian_projected );

                        //Both prime meridians are not similar
                        if ( tangent_function_ratio_prime_meridian > similarity_ratio )
                        {
                                return false;
                        }
                }
        }

        //Process all parallels
        for ( typename TParallelsList <T> ::Type::const_iterator i_parallels = parallels->begin(); i_parallels != parallels->end(); ++ i_parallels )
        {
                //Find equator
                if ( ( *i_parallels ).getLatitude() == 0 )
                {
                        //Convert test meridian to Points2D list
                        Container <Point3DCartesian <T> > pl_parallel_test ( nl_test, & ( ( * i_parallels ).getPointsIndices () ) );

                        //Convert projected meridian to Points2D list
                        Container <Point3DCartesian <T> > pl_parallel_projected ( nl_projected,  & ( ( * i_parallels ).getPointsIndices () ) );

                        //Compute tangent function difference for each parallel
                        T tangent_function_ratio_equator = TangentFunction::compare2PolyLinesUsingTangentFunction ( &pl_parallel_test, &pl_parallel_projected );

                        //Both equators are not similar
                        if ( tangent_function_ratio_equator > similarity_ratio )
                        {
                                return false;
                        }
                }

                //Find north pole
                if ( ( *i_parallels ).getLatitude() == 90 )
                {
                        //Convert test parallel to Points2D list
                        Container <Point3DCartesian <T> > pl_parallel_test ( nl_test, & ( ( * i_parallels ).getPointsIndices () ) );

                        //Convert projected parallel to Points2D list
                        Container <Point3DCartesian <T> > pl_parallel_projected ( nl_projected,  & ( ( * i_parallels ).getPointsIndices () ) );

                        //Compute tangent function difference for each parallel
                        T tangent_function_ratio_north_pole = TangentFunction::compare2PolyLinesUsingTangentFunction ( &pl_parallel_test, &pl_parallel_projected );

                        //Both north poles are not similar
                        if ( tangent_function_ratio_north_pole > similarity_ratio )
                        {
                                return false;
                        }

                }

                //Find south pole
                if ( ( *i_parallels ).getLatitude() == -90 )
                {
                        //Convert test parallel to Points2D list
                        Container <Point3DCartesian <T> > pl_parallel_test ( nl_test, & ( ( * i_parallels ).getPointsIndices () ) );

                        //Convert projected parallel to Points2D list
                        Container <Point3DCartesian <T> > pl_parallel_projected ( nl_projected,  & ( ( * i_parallels ).getPointsIndices () ) );

                        //Compute tangent function difference for each parallel
                        T tangent_function_ratio_south_pole = TangentFunction::compare2PolyLinesUsingTangentFunction ( &pl_parallel_test, &pl_parallel_projected );

                        //Both south poles are not similar
                        if ( tangent_function_ratio_south_pole > similarity_ratio )
                        {
                                return false;
                        }
                }
        }

        return true;
}


template <typename T>
void CartAnalysis::sortSamplesByComputedRatios ( Container <Sample <T> * > *sl, const TAnalysis & analysis )
{

        //Sort results: Cross nearest distance
        if ( analysis.a1 )
        {
                std::sort ( sl->begin(), sl->end(), sortSamplesByCrossNearestNeighbourDistanceRatio () );
        }

        //Set positions for sorted samples
        setPositionForSortedSamples ( sl, 1 );

        //Sort results: Average nearest distance
        if ( analysis.a2 )
        {
                std::sort ( sl->begin(), sl->end(), sortSamplesByAverageNearestNeighbourDistanceRatio () );
        }

        //Set positions for sorted samples
        setPositionForSortedSamples ( sl, 2 );

        //Sort results: Helmert transformation, standard deviation
        if ( analysis.a3 )
        {
                std::sort ( sl->begin(), sl->end(), sortSamplesBySimilarityTransformationRatio () );
        }

        //Set positions for sorted samples
        setPositionForSortedSamples ( sl, 3 );

        //Sort results: angular differences
        if ( analysis.a4 )
        {
                std::sort ( sl->begin(), sl->end(), sortSamplesByAngularDifferencesRatio() );
        }

        //Set positions for sorted samples
        setPositionForSortedSamples ( sl, 4 );

        //Sort results: tangent function difference ratio
        if ( analysis.a5 )
        {
                std::sort ( sl->begin(), sl->end(), sortSamplesByTangentFunctionRatio() );
        }

        //Set positions for sorted samples
        setPositionForSortedSamples ( sl, 5 );

        //Sort results: k-nn graph ratio
        if ( analysis.a6 )
        {
                std::sort ( sl->begin(), sl->end(), sortSamplesByNNNGraphRatio() );
        }

        //Set positions for sorted samples
        setPositionForSortedSamples ( sl, 6 );

        //Sort results: Gabriel graph ratio
        if ( analysis.a7 )
        {
                std::sort ( sl->begin(), sl->end(), sortSamplesBySphereOfInfluenceGraphRatio() );
        }

        //Set positions for sorted samples
        setPositionForSortedSamples ( sl, 7 );

        //Sort results: Voronoi cell Area/Length ratio
        if ( analysis.a8 )
        {
                std::sort ( sl->begin(), sl->end(), sortSamplesByVoronoiCellAreaLengthRatio() );
        }

        //Set positions for sorted samples
        setPositionForSortedSamples ( sl, 8 );

        //Sort results: Voronoi cell Tangent Function Ratio
        if ( analysis.a9 )
        {
                std::sort ( sl->begin(), sl->end(), sortSamplesByVoronoiCellTangentFunctionRatio() );
        }

        //Set positions for sorted samples
        setPositionForSortedSamples ( sl, 9 );

        //Sort results: Voronoi cell TAR ratio
        if ( analysis.a10 )
        {
                std::sort ( sl->begin(), sl->end(), sortSamplesByVoronoiCellTARRatio() );
        }

        //Set positions for sorted samples
        setPositionForSortedSamples ( sl, 10 );

        //Sort results: Voronoi cell Inner Distance ratio
        if ( analysis.a11 )
        {
                std::sort ( sl->begin(), sl->end(), sortSamplesByVoronoiCellInnerDistanceRatio() );
        }

        //Set positions for sorted samples
        setPositionForSortedSamples ( sl, 11 );

        //Sort samples by all ratios
        std::sort ( sl->begin(), sl->end(), sortSamplesByAllRatios ( analysis ) );
}


template <typename T>
void CartAnalysis::setPositionForSortedSamples ( Container <Sample <T> *> *sl, const unsigned short analysis_type )
{
        //Set position for each sample after its sorting
        unsigned int n = sl->size();

        for ( unsigned int i = 0; i < n; i++ )
        {
                //Cross nearest distance criterion
                if ( analysis_type == 1 )
                {
                        ( *sl ) [i]->setCrossNearestDistancePosition ( i + 1 );
                }

                //Average nearest distance criterion
                if ( analysis_type == 2 )
                {
                        ( *sl ) [i]->setAverageNearestDistancePosition ( i + 1 );
                }

                //Helmert transformation, standard deviation criterion
                if ( analysis_type == 3 )
                {
                        ( *sl ) [i]->setSimilaritytransformationRatioPosition ( i + 1 );
                }

                //Angular difference criterion (meridians and parallels)
                else if ( analysis_type == 4 )
                {
                        ( *sl ) [i]->setAngularDifferencePosition ( i + 1 );
                }

                //Tangent function criterion (meridians and parallels)
                else if ( analysis_type == 5 )
                {
                        ( *sl ) [i]->setTangentFunctionRatioPosition ( i + 1 );
                }

                //K-nn graph ratio
                else if ( analysis_type == 6 )
                {
                        ( *sl ) [i]->setNNNGraphRatioPosition ( i + 1 );
                }

                else if ( analysis_type == 7 )
                {
                        ( *sl ) [i]->setSphereOfInfulenceGraphRatioPosition ( i + 1 );
                }

                //Voronoi cell area/length criterion
                else if ( analysis_type == 8 )
                {
                        ( *sl ) [i]->setVoronoiCellAreaLengthRatioPosition ( i + 1 );
                }

                //CVoronoi cell tangent function criterion
                else if ( analysis_type == 9 )
                {
                        ( *sl ) [i]->setVoronoiCellTangentFunctionRatioPosition ( i + 1 );
                }

                //Voronoi cell TAR criterion
                else if ( analysis_type == 10 )
                {
                        ( *sl ) [i]->setVoronoiCellTARRatioPosition ( i + 1 );
                }

                //Voronoi cell Inner Distance criterion
                else if ( analysis_type == 11 )
                {
                        ( *sl ) [i]->setVoronoiCellInnerDistanceRatioPosition ( i + 1 );
                }
        }
}


template <typename T>
void CartAnalysis::printResults ( const Container <Sample <T> *> *sl, unsigned int items_printed, const TAnalysis & analysis, const Projection <T> *analyzed_proj, std::ostream * output )
{
        //Print first n items sorted by the similarity match ratio
        unsigned int n = sl->size();

        //Correct number of printed items
        if ( items_printed > n )
        {
                items_printed = n;
        }

        //Some points were loaded
        if ( n > 0 )
        {
                //Table  1
                *output << "Projections sorted by criterions values:" << std::endl << std::endl;

                //Set properties
                *output << std::showpoint << std::fixed << std::right;

                //Create header 1 : results of analalysis
                *output	<< std::setw ( 3 ) << "#"
                << std::setw ( 6 ) << "Proj"
                << std::setw ( 5 ) << "LatP"
                << std::setw ( 5 ) << "LonP"
                << std::setw ( 5 ) << "lat0"
                << std::setw ( 5 ) << "CND"
                << std::setw ( 5 ) << "AND"
                << std::setw ( 6 ) << "STD"
                << std::setw ( 5 ) << "GNAD"
                << std::setw ( 5 ) << "GNTF"
                << std::setw ( 5 ) << "NNNG"
                << std::setw ( 5 ) << "SIG"
                << std::setw ( 5 ) << "VDAL"
                << std::setw ( 5 ) << "VDTF"
                << std::setw ( 5 ) << "VDTA"
                << std::setw ( 5 ) << "VDID" << std::endl;

                //Values of the criterion for each projection
                for ( unsigned int i = 0;  i < ( analyzed_proj == NULL ? items_printed : n ); i++ )
                {
                        if ( analyzed_proj == NULL )
                        {
                                ( *sl ) [i] -> printSampleRatios ( output, i + 1, analysis );
                        }

                        else if ( ( * sl ) [i]->getAnalyzedProjectionSample() )
                        {
                                ( *sl ) [i] -> printSampleRatios ( output, i + 1, analysis );
                                break;
                        }
                }

                //Table 2
                *output << std::endl << "Projections sorted by criterions positions:" << std::endl << std::endl;

                //Create header 2: positions
                *output	<< std::setw ( 3 ) << "#"
                << std::setw ( 6 ) << "Proj"
                << std::setw ( 5 ) << "LatP"
                << std::setw ( 5 ) << "LonP"
                << std::setw ( 5 ) << "lat0"
                << std::setw ( 5 ) << "CND"
                << std::setw ( 5 ) << "AND"
                << std::setw ( 5 ) << "STD"
                << std::setw ( 5 ) << "GNAD"
                << std::setw ( 5 ) << "GNTF"
                << std::setw ( 5 ) << "NNNG"
                << std::setw ( 5 ) << "SIG"
                << std::setw ( 5 ) << "VDAL"
                << std::setw ( 5 ) << "VDTF"
                << std::setw ( 5 ) << "VDTA"
                << std::setw ( 5 ) << "VDID" << std::endl;

                //Positions of the criterion for each projection
                for ( unsigned int i = 0;  i < ( analyzed_proj == NULL ? items_printed : n ); i++ )
                {
                        if ( analyzed_proj == NULL )
                        {
                                ( *sl ) [i] -> printSamplePositions ( output, i + 1, analysis );
                        }

                        else if ( ( * sl ) [i]->getAnalyzedProjectionSample() )
                        {
                                ( *sl ) [i] -> printSamplePositions ( output, i + 1, analysis );
                                break;
                        }
                }

                *output << std::endl;
        }
}


//Each sample analysis
template <typename T>
void CartAnalysis::analyzeSampleCrossNearestNeighbourDistance ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                Container <Node3DCartesian <T> *> *nl_transformed )
{
        //Analyze all samples using cross nearest distance ratio
        try
        {
                //Compute similarity transformation
                if ( nl_transformed->size() == 0 )
                {
                        Helmert::transformPoints2D ( nl_projected, nl_test, nl_transformed );
                }

                //Compute cross nearest distance ratio
                T cross_nearest_neighbour_distance_ratio = NNDistance::getCrossNearestNeighbourDistance ( nl_projected, nl_transformed );

                //Set ratio for the sample
                s->setCrossNearestNeighbourDistanceRatio ( cross_nearest_neighbour_distance_ratio );
        }

        //Throw exception
        catch ( Error & error )
        {
                s->setCrossNearestNeighbourDistanceRatio ( MAX_FLOAT );
        }
}


template <typename T>
void CartAnalysis::analyzeSampleAverageNearestNeighbourDistance ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test, const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                Container <Node3DCartesian <T> *> *nl_transformed )
{
        //Analyze all samples using average nearest neighbour distance ratio
        try
        {
                //Compute similarity transformation
                if ( nl_transformed->size() == 0 )
                {
                        Helmert::transformPoints2D ( nl_projected, nl_test, nl_transformed );
                }

                //Compute average nearest distance ratio
                T average_nearest_neighbour_distance_ratio = NNDistance::compare2DatasetsUsingAverageNearestNeighbourDistance ( nl_projected, nl_transformed );

                //Set ratio for the sample
                s->setAverageNearestNeighbourDistanceRatio ( average_nearest_neighbour_distance_ratio );
        }

        //Throw exception
        catch ( Error & error )
        {
                s->setAverageNearestNeighbourDistanceRatio ( MAX_FLOAT );
        }
}


template <typename T>
void CartAnalysis::analyzeSampleSimilaritytransformationDeviation ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                Container <Node3DCartesian <T> *> *nl_transformed )
{
        //Analyze sample using similarity transformation deviation
        try
        {
                //Compute similarity transformation
                if ( nl_transformed->size() == 0 )
                {
                        Helmert::transformPoints2D ( nl_projected, nl_test, nl_transformed );
                }

                //Compute ratio
                T similarity_transformation_ratio = Helmert::getStandardDeviation2D ( nl_projected, nl_transformed );

                //Set ratio for the sample
                s->setSimilaritytransformationRatio ( similarity_transformation_ratio );
        }

        //Throw exception
        catch ( Error & error )
        {
                s->setSimilaritytransformationRatio ( MAX_FLOAT );
        }
}


template <typename T>
void CartAnalysis::analyzeSampleGeographicNetworkAngularDifference ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                const typename TMeridiansList <T> ::Type * meridians, const typename TParallelsList <T> ::Type * parallels )
{
        //Analyze sample using angular differences in geographic network
        T angular_difference_meridians = 0, angular_difference_parallels = 0;

        try
        {
                //Analyze meridians
                typename TMeridiansList <T> ::Type::const_iterator i_meridians = meridians->begin();

                //Process all meridians
                for ( i_meridians = meridians->begin(); i_meridians != meridians->end(); ++i_meridians )
                {
                        //Process all points of the meridian
			for ( unsigned int i = 1; i < ( *i_meridians ).getPointsIndices ().size() - 1; i++ )
			{
				const unsigned int i1 = ( *i_meridians ).getPointsIndices () [i-1], i2 = ( *i_meridians ).getPointsIndices () [i], i3 = ( *i_meridians ).getPointsIndices () [i+1];
				
				//Compute angles
				const T angle_test = Angle3Points::getAngle3Points ( ( *nl_test ) [i1], ( *nl_test ) [i2], ( *nl_test ) [i3] );
				const T angle_projected = Angle3Points::getAngle3Points ( ( *nl_projected ) [i1], ( *nl_projected ) [i2], ( *nl_projected ) [i3] );

				//Compute differences
				if ( angle_test + angle_projected != 0 )
				{
					angular_difference_meridians += ( angle_test - angle_projected ) * ( angle_test - angle_projected ) / ( angle_test + angle_projected );
				}
			}
                }

                //Analyze parallels
                typename TParallelsList <T> ::Type::const_iterator i_parallels = parallels->begin();

                //Process all parallels
                for ( i_parallels = parallels->begin(); i_parallels != parallels->end(); ++i_parallels )
                {
                        //Process all points of the parallel
			for ( unsigned int i = 1; i < ( *i_parallels ).getPointsIndices ().size() - 1; i++ )
			{
				const unsigned int i1 = ( *i_parallels ).getPointsIndices () [i-1], i2 = ( *i_parallels ).getPointsIndices () [i], i3 = ( *i_parallels ).getPointsIndices () [i+1];
				
				//Compute angles
				const T angle_test = Angle3Points::getAngle3Points ( ( *nl_test ) [i1], ( *nl_test ) [i2], ( *nl_test ) [i3] );
				const T angle_projected = Angle3Points::getAngle3Points ( ( *nl_projected ) [i1], ( *nl_projected ) [i2], ( *nl_projected ) [i3] );

				//Compute angular differences
				if ( angle_test + angle_projected != 0 )
				{
					angular_difference_parallels += ( angle_test - angle_projected ) * ( angle_test - angle_projected ) / ( angle_test + angle_projected );
				}
			}
                }

                //Set angular difference
                s->setAngularDifferenceRatio ( 100 * ( angular_difference_meridians + angular_difference_parallels) );
        }

        //Throw exception
        catch ( Error & error )
        {
                s->setAngularDifferenceRatio ( MAX_FLOAT );
        }
}


template <typename T>
void CartAnalysis::analyzeSampleGeographicNetworkTangentFunctionRatio ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                const typename TMeridiansList <T> ::Type * meridians, const typename TParallelsList <T> ::Type * parallels )
{
        //Analyze sample using angular tangent function differences in geographic network
        T tangent_function_ratio_meridians = 0, tangent_function_ratio_parallels = 0;

        try
        {
                typename TMeridiansList <T> ::Type::const_iterator i_meridians = meridians->begin();

                //Process all meridians
                for ( i_meridians = meridians->begin(); i_meridians != meridians->end(); ++i_meridians )
                {
                        //Convert test meridian to Points 2D list
                        Container <Point3DCartesian <T> > pl_meridian_test ( nl_test, & ( ( * i_meridians ).getPointsIndices () ) );

                        //Convert projected meridian to Points2D list
                        Container <Point3DCartesian <T> > pl_meridian_projected ( nl_projected,  & ( ( * i_meridians ).getPointsIndices () ) );

                        //Compute tangent function difference for each test and projected meridian
                        tangent_function_ratio_meridians += TangentFunction::compare2PolyLinesUsingTangentFunction ( &pl_meridian_test, &pl_meridian_projected );
                }

                typename TParallelsList <T> ::Type::const_iterator i_parallels = parallels->begin();

                //Process all parallels
                for ( i_parallels = parallels->begin(); i_parallels != parallels->end(); ++i_parallels )
                {
                        //Convert test meridian to Points2D list
                        Container <Point3DCartesian <T> > pl_parallel_test ( nl_test, & ( ( * i_parallels ).getPointsIndices () ) );

                        //Convert projected meridian to Points2D list
                        Container <Point3DCartesian <T> > pl_parallel_projected ( nl_projected,  & ( ( * i_parallels ).getPointsIndices () ) );

                        //Compute tangent function difference for each parallel
                        tangent_function_ratio_parallels += TangentFunction::compare2PolyLinesUsingTangentFunction ( &pl_parallel_test, &pl_parallel_projected );
                }

                //Set tangent function ratio
                s->setTangentFunctionRatio ( tangent_function_ratio_meridians  +  tangent_function_ratio_parallels );
        }

        //Throw exception
        catch ( Error & error )
        {
                s->setTangentFunctionRatio ( MAX_FLOAT );
        }

}


template <typename T>
void CartAnalysis::analyzeSampleKNNGraphRatio ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                Container <Node3DCartesian <T> *> *nl_transformed )
{
        //Analyze sample using 8 nearest neighbours graph ratio (X quadrat)
        try
        {
                //Compute similarity transformation
                if ( nl_transformed->size() == 0 )
                {
                        Helmert::transformPoints2D ( nl_projected, nl_test, nl_transformed );
                }

                //Create graphs
                GraphM <T> g_test ( nl_test->size() ), g_projected ( nl_projected->size() );

                GraphAlgorithms::createKNNGraph ( nl_test, 9, g_test );
                GraphAlgorithms::createKNNGraph ( nl_projected, 9, g_projected );

                //Compute ratio
                T knn_graph_ratio = 0;

                for ( unsigned int i = 0; i < nl_test->size(); i++ )
                {
                        for ( unsigned int j = 0; j < nl_test->size(); j++ )
                        {
                                if ( g_test.getW() ( i, j ) + g_projected.getW() ( i, j ) != 0 )
                                {
                                        knn_graph_ratio +=	( g_test.getW() ( i, j ) - g_projected.getW() ( i, j ) ) * ( g_test.getW() ( i, j ) - g_projected.getW() ( i, j ) ) /
                                                                ( g_test.getW() ( i, j ) + g_projected.getW() ( i, j ) ) ;
                                }
                        }
                }

                //Set ratio for the sample
                s->setKNNGraphRatio ( knn_graph_ratio );
        }

        //Throw exception
        catch ( Error & error )
        {
                s->setKNNGraphRatio ( MAX_FLOAT );
        }
}


template <typename T>
void CartAnalysis::analyzeSampleNNNGraphRatio ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                Container <Node3DCartesian <T> *> *nl_transformed )
{
        //Analyze sample using natural nearest neighbours graph ratio (X quadrat)
        try
        {
                //Compute similarity transformation
                if ( nl_transformed->size() == 0 )
                {
                        Helmert::transformPoints2D ( nl_projected, nl_test, nl_transformed );
                }

                //Compute Voronoi diagram
                Container <HalfEdge <T> *> hl_dt_reference, hl_vor_reference;
                Container <Node3DCartesian <T> *> nl_vor_reference;
                Container <VoronoiCell <T> *> vor_list_reference;

                //Create Voronoi diagram for the reference dataset
                Voronoi2D::VD ( ( Container <Node3DCartesian <T> *> * ) nl_projected, &nl_vor_reference, &hl_dt_reference, &hl_vor_reference, &vor_list_reference, BoundedCells, TopologicApproach, 0, 1 );

                //Create graphs
                GraphM <T> g_test ( nl_test->size() ), g_projected ( nl_projected->size() );

                GraphAlgorithms::createNNNGraph ( nl_test, g_test );
                GraphAlgorithms::createNNNGraph ( nl_projected, g_projected );

                //Compute ratio
                T nnn_graph_ratio = 0;

                for ( unsigned int i = 0; i < nl_test->size(); i++ )
                {
                        for ( unsigned int j = 0; j < nl_test->size(); j++ )
                        {
                                if ( g_test.getW() ( i, j ) + g_projected.getW() ( i, j ) != 0 )
                                {
                                        nnn_graph_ratio +=	( g_test.getW() ( i, j ) - g_projected.getW() ( i, j ) ) * ( g_test.getW() ( i, j ) - g_projected.getW() ( i, j ) ) /
                                                                ( g_test.getW() ( i, j ) + g_projected.getW() ( i, j ) ) ;
                                }
                        }
                }

                //Set ratio for the sample
                s->setNNNGraphRatio ( nnn_graph_ratio );
        }

        //Throw exception
        catch ( Error & error )
        {
                s->setNNNGraphRatio ( MAX_FLOAT );
        }
}


template <typename T>
void CartAnalysis::analyzeSampleSphereOfInfulenceGraphRatio ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test, const  Container <Node3DCartesianProjected  <T> *> *nl_projected,
                Container <Node3DCartesian <T> *> *nl_transformed )
{
        //Analyze sample using four Gabriel graph ratio (neighbour matrix difference)
        try
        {
                //Compute similarity transformation
                if ( nl_transformed->size() == 0 )
                {
                        Helmert::transformPoints2D ( nl_projected, nl_test, nl_transformed );
                }

                //Create graph
                GraphM <T> g_test ( nl_test->size() ), g_projected ( nl_projected->size() );

                GraphAlgorithms::createSphereOfInfulenceGraph ( nl_test, g_test );
                GraphAlgorithms::createSphereOfInfulenceGraph ( nl_projected, g_projected );

                //Compute ratio
                T sphere_of_infulence_graph_ratio = 0;

                for ( unsigned int i = 0; i < nl_test->size(); i++ )
                {
                        for ( unsigned int j = 0; j < nl_test->size(); j++ )
                        {
                                if ( g_test.getW() ( i, j ) + g_projected.getW() ( i, j ) != 0 )
                                {
                                        sphere_of_infulence_graph_ratio +=	( g_test.getW() ( i, j ) - g_projected.getW() ( i, j ) ) * ( g_test.getW() ( i, j ) - g_projected.getW() ( i, j ) ) /
                                                                                ( g_test.getW() ( i, j ) + g_projected.getW() ( i, j ) ) ;
                                }
                        }
                }

                //Set ratio for the sample
                s->setSphereOfInfulenceGraphRatio ( sphere_of_infulence_graph_ratio );

        }

        //Throw exception
        catch ( Error & error )
        {
                s->setSphereOfInfulenceGraphRatio ( MAX_FLOAT );
        }
}


template <typename T>
void CartAnalysis::analyzeSampleUsingVoronoiDiagramRatio ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test, const Container <Node3DCartesianProjected  <T> *> *nl_projected, const Container <Face <T> *> *faces_test, TAnalysis & analysis )
{
        //Analyze sample using Voronoi diagram ratios
        T area_length_difference = 0, tangent_function_difference = 0, tar_difference = 0, inner_distance_difference = 0;

        //Voronoi diagram, data structures
        Container <HalfEdge <T> *> hl_dt_reference, hl_vor_reference;
        Container <Node3DCartesian <T> *> nl_vor_reference;
        Container <VoronoiCell <T> *> vor_list_reference;

        //Create Voronoi diagram for the reference dataset
        Voronoi2D::VD ( ( Container <Node3DCartesian <T> *> * ) nl_projected, &nl_vor_reference, &hl_dt_reference, &hl_vor_reference, &vor_list_reference, BoundedCells, TopologicApproach, 0, 1 );

        try
        {
                //Get total unbounded cells for the test dataset
                unsigned int unbounded_cells_reference_total = vor_list_reference.size();
                unsigned int unbounded_pairs_total = 0;

                //Not enough unbounded cells (not enough points or wrong configuration)
                if ( unbounded_cells_reference_total < 3 )
                {
                        if ( analysis.a8 ) s->setVoronoiCellAreaLengthRatio ( MAX_FLOAT );

                        if ( analysis.a9 ) s->setVoronoiCellTangentFunctionRatio ( MAX_FLOAT );

                        if ( analysis.a10 ) s->setVoronoiCellTARRatio ( MAX_FLOAT );

                        if ( analysis.a11 ) s->setVoronoiCellInnerDistanceRatio ( MAX_FLOAT );
                }

                typename TItemsList <Node3DCartesian <T> *>::Type ::const_iterator i_points_test = nl_test->begin();
                typename TItemsList <Node3DCartesianProjected <T> *>::Type ::const_iterator i_points_reference = nl_projected->begin();

                for ( unsigned int index_merged_faces = 0; ( i_points_test != nl_test->end() ) && ( i_points_reference != nl_projected->end() ); i_points_test ++, i_points_reference ++ )
                {
                        //Get Voronoi faces
                        VoronoiCell <T> *vor_cell_test = dynamic_cast < VoronoiCell <T> * > ( ( *i_points_test ) -> getFace() );
                        VoronoiCell <T> *vor_cell_reference = dynamic_cast < VoronoiCell <T> * > ( ( *i_points_reference ) -> getFace() );

                        //Merged test face exists, reference Voronoi cell exists and is bounded
                        if ( ( vor_cell_test != NULL ) && ( vor_cell_test->getBounded() ) )
                        {
                                if ( ( vor_cell_reference != NULL ) && ( vor_cell_reference->getBounded() ) )
                                {

                                        Face <T> * face_reference = NULL;
                                        Container < Node3DCartesian <T> *> intersections_reference;

                                        //Merge reference cell with adjacent cells
                                        Voronoi2D::mergeVoronoiCellAndAdjacentCells ( vor_cell_reference, &face_reference, &intersections_reference );

                                        //Increment counter
                                        unbounded_pairs_total ++;

                                        //Compute area/length ratio using X quadrat
                                        if ( analysis.a8 )
                                        {
                                                T face_perimeter_test = FacePerimeter::getFacePerimeter ( ( * faces_test ) [index_merged_faces] ), face_perimeter_reference = FacePerimeter::getFacePerimeter ( face_reference );
						T face_area_test_norm = FaceArea::getFaceArea ( ( * faces_test ) [index_merged_faces] ) / ( face_perimeter_test * face_perimeter_test), face_area_reference_norm = FaceArea::getFaceArea ( face_reference ) / 
									( face_perimeter_reference * face_perimeter_reference );
                                                
                                                area_length_difference += 100 * ( face_area_test_norm - face_area_reference_norm ) * ( face_area_test_norm - face_area_reference_norm ) / ( face_area_test_norm + face_area_reference_norm );
                                        }

                                        //Compute tangent function difference
                                        if ( analysis.a9 ) tangent_function_difference +=  TangentFunction::compare2FacesUsingTangentFunction ( ( * faces_test ) [index_merged_faces] , face_reference );

                                        //Compute tar difference
                                        if ( analysis.a10 ) tar_difference +=  TARCriterion::compare2FacesUsingTARCriterion ( ( * faces_test ) [index_merged_faces] , face_reference );

                                        //Compute inner distance difference
                                        if ( analysis.a11 )
                                                inner_distance_difference +=  InnerDistance::compare2FacesUsingInnerDistances ( ( * faces_test ) [index_merged_faces] , face_reference );
                                }

                                index_merged_faces ++;
                        }
                }

                //No corresponding pair of Voronoi cells
                if ( unbounded_pairs_total < 3 )
                {
                        if ( analysis.a8 ) s->setVoronoiCellAreaLengthRatio ( MAX_FLOAT );

                        if ( analysis.a9 ) s->setVoronoiCellTangentFunctionRatio ( MAX_FLOAT );

                        if ( analysis.a10 ) s->setVoronoiCellTARRatio ( MAX_FLOAT );

                        if ( analysis.a11 ) s->setVoronoiCellInnerDistanceRatio ( MAX_FLOAT );
                }

                //Set result of analysis
                else
                {
                        if ( analysis.a8 ) s->setVoronoiCellAreaLengthRatio ( sqrt ( area_length_difference / unbounded_pairs_total ) );

                        if ( analysis.a9 ) s->setVoronoiCellTangentFunctionRatio ( sqrt ( tangent_function_difference / unbounded_pairs_total ) );

                        if ( analysis.a10 ) s->setVoronoiCellTARRatio ( sqrt ( tar_difference / unbounded_pairs_total ) );

                        if ( analysis.a11 ) s->setVoronoiCellInnerDistanceRatio ( sqrt ( inner_distance_difference / unbounded_pairs_total ) );
                }
        }

        //Error while sample processed
        catch ( Error & error )
        {
                //Do not compute other analysis
                if ( analysis.a8 ) s->setVoronoiCellAreaLengthRatio ( MAX_FLOAT );

                if ( analysis.a9 ) s->setVoronoiCellTangentFunctionRatio ( MAX_FLOAT );

                if ( analysis.a10 ) s->setVoronoiCellTARRatio ( MAX_FLOAT );

                if ( analysis.a11 ) s->setVoronoiCellInnerDistanceRatio ( MAX_FLOAT );
        }
}



#endif
