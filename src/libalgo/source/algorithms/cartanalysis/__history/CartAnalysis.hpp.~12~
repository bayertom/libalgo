// Description: Performs cartometric analysis (i.e. detection of the cartographic projection)

// Copyright (c) 2010 - 2011
// Tomas Bayer
// Charles University in Prague, Faculty of Science
// bayertom@natur.cuni.cz

// This library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this library. If not, see <http://www.gnu.org/licenses/>.


#ifndef CartAnalysis_HPP
#define CartAnalysis_HPP

#include <algorithm>
#include <iomanip>
#include <cmath>


#include "libalgo/source/const/Const.h"

#include "libalgo/source/structures/point/Node3DCartesianProjected.h"
#include "libalgo/source/structures/projection/Sample.h"

#include "libalgo/source/algorithms/cartdistortion/CartDistortion.h"
#include "libalgo/source/algorithms/carttransformation/CartTransformation.h"
#include "libalgo/source/algorithms/transformation/HomotheticTransformation2D.h"
#include "libalgo/source/algorithms/transformation/HelmertTransformation2D.h"
#include "libalgo/source/algorithms/angle3points/Angle3Points.h"
#include "libalgo/source/algorithms/facearea/FaceArea.h"

#include "libalgo/source/algorithms/turningfunction/TurningFunction.h"
//#include "libalgo/source/algorithms/innerdistance/InnerDistance.h"
#include "libalgo/source/algorithms/nndistance/NNDistance.h"
//#include "libalgo/source/algorithms/tarcriterion/TARCriterion.h"
#include "libalgo/source/algorithms/voronoi2D/Voronoi2D.h"

#include "libalgo/source/comparators/sortPointsByID.h"
#include "libalgo/source/comparators/sortPointsByX.h"

#include "libalgo/source/comparators/removeUnequalMeridianParallelPointIndices.h"
#include "libalgo/source/comparators/findMeridianParallelPointIndices.h"

#include "libalgo/source/comparators/sortSamplesByCrossNearestNeighbourDistanceRatio.h"
#include "libalgo/source/comparators/sortSamplesByAverageNearestNeighbourDistanceRatio.h"
#include "libalgo/source/comparators/sortSamplesByHomotheticTransformationRatio.h"
#include "libalgo/source/comparators/sortSamplesByHelmertTransformationRatio.h"
#include "libalgo/source/comparators/sortSamplesByAngularDifferencesRatio.h"
#include "libalgo/source/comparators/sortSamplesByGNTurningFunctionRatio.h"
#include "libalgo/source/comparators/sortSamplesByNNNGraphRatio.h"
#include "libalgo/source/comparators/sortSamplesBySphereOfInfluenceGraphRatio.h"
#include "libalgo/source/comparators/sortSamplesByVoronoiCellAreaLengthRatio.h"
#include "libalgo/source/comparators/sortSamplesByVoronoiCellTurningFunctionRatio.h"
#include "libalgo/source/comparators/sortSamplesByVoronoiCellTARRatio.h"
#include "libalgo/source/comparators/sortSamplesByVoronoiCellInnerDistanceRatio.h"
#include "libalgo/source/comparators/sortSamplesByAllRatios.h"

#include "libalgo/source/exceptions/ErrorMath.h"

#include "libalgo/source/io/DXFExport.h"


template <typename T>
void CartAnalysis::computeAnalysisForAllSamples ( Container <Sample <T> > *sl, Container <Projection <T> *> *pl, Container <Node3DCartesian <T> *> *nl_test, Container <Point3DGeographic <T> *> *pl_reference,
                typename TMeridiansList <T> ::Type meridians, typename TParallelsList <T> ::Type parallels, const Container <Face <T> *> *faces_test, TAnalysisParameters <T> & analysis_parameters,
                unsigned int & total_created_or_thrown_samples, const bool print_exception, std::ostream * output )
{
        //Total computed analysis ( successful + thrown by the heuristic )
        total_created_or_thrown_samples = 0;

        //Total successfully computed analysis for one cartographic projection
        unsigned int total_created_and_analyzed_samples_projection = 0;

        //Create sample for analyzed projection and set flag for this sample
        if ( analysis_parameters.analyzed_proj_index > 0 )
        {
                //Get analyzed proj
                const Projection <T> *analyzed_proj = ( *pl ) [analysis_parameters.analyzed_proj_index];

                //Compute analysis
                computeAnalysisForOneSample ( sl, pl, nl_test, pl_reference, meridians, parallels, faces_test, analyzed_proj, analysis_parameters,
                                              total_created_and_analyzed_samples_projection, print_exception, output );

                //Sample with analyzed projection has been successfully created (not thrown by the heuristic)
                if ( total_created_and_analyzed_samples_projection > 0 ) ( *sl ) [0].setAnalyzedProjectionSample ( true );
                else return;
        }

        //Process all cartographic projections from the list one by one
        for ( typename TItemsList <Projection <T> *> ::Type ::const_iterator i_projections = pl->begin(); i_projections != pl->end(); ++ i_projections )
        {
                //Get limits of the cartographic pole latitude and longitude: some projections are defined only in normal position
                total_created_and_analyzed_samples_projection = 0;

                //Print actual projection name to the log
                *output << ( *i_projections ) -> getProjectionName() << ": ";

                //Cast actual projection to projection with limits ( get projection limits and other parameters )
                const ProjectionLimits <T> *proj_limits = dynamic_cast <ProjectionLimits <T> *> ( *i_projections );

                if ( proj_limits != NULL )
                {
                        //Process oblique position of the cartographic projection
                        //T latp = 0.0;
			for ( T latp  = ( analysis_parameters.analyze_oblique_position ? ( proj_limits ) -> getLatPoleMin() : 90 );
                                        latp <= ( analysis_parameters.analyze_oblique_position ? ( proj_limits ) -> getLatPoleMax() : 90 ); latp += analysis_parameters.latp_step )
                        {
				//T lonp = 80.0;
                                for ( T lonp = ( fabs ( latp ) == 90 ? 0 : ( proj_limits ) -> getLonPoleMin() ) ;
                                                fabs ( latp ) == 90 ? lonp == 0 : lonp <= ( proj_limits ) -> getLonPoleMax();  lonp += analysis_parameters.lonp_step )
                                {
                                        ////Process all undistorted meridians
                                        //T lat0 = 40;
					for ( T lat0 = ( proj_limits )-> getLat0Min(); lat0 <= ( proj_limits )-> getLat0Max(); lat0 += analysis_parameters.lat0_step )
                                        {
                                                //Set  the projection parameters
                                                ( * i_projections )->setCartPole ( Point3DGeographic <T> ( latp, lonp ) );
                                                ( * i_projections )->setLat0 ( lat0 );

                                                //Compute analysis for one sample
                                                computeAnalysisForOneSample ( sl, pl, nl_test, pl_reference, meridians, parallels, faces_test, *i_projections, analysis_parameters,
                                                                              total_created_and_analyzed_samples_projection, print_exception, output );

                                                //Print "." for every 1000-th sample to the log
                                                if ( total_created_or_thrown_samples % 1000 == 0 )
                                                {
                                                        std::cout.flush();
                                                        std::cout << ".";
                                                }

                                                //Increment number of samples
                                                total_created_or_thrown_samples ++;
                                        }
                                }
                        }
                }

                //Print successfully analyzed samples for one cartographic projection
                *output << " [" << total_created_and_analyzed_samples_projection << " created]" << std::endl;
        }
}


template <typename T>
void CartAnalysis::computeAnalysisForOneSample ( Container <Sample <T> > *sl, Container <Projection <T> *> *pl, Container <Node3DCartesian <T> *> *nl_test, Container <Point3DGeographic <T> *> *pl_reference, typename TMeridiansList <T> ::Type meridians, typename TParallelsList <T> ::Type parallels,
                const Container <Face <T> *> *faces_test, const Projection <T> *proj, TAnalysisParameters <T> & analysis_parameters, unsigned int & total_created_and_analyzed_samples_projection, const bool print_exception, std::ostream * output )
{
        //Compute all cartometric analysis for one sample
        try
        {
                //Create empty list of projected points and transformed points
                Container <Node3DCartesianProjected <T> *> nl_projected;
                Container <Node3DCartesian <T> *> nl_transformed;
                Container <Point3DGeographic <T> > pl_oblique;

		double latpt = proj->getCartPole().getLat();
		double lonpt = proj->getCartPole().getLon();
		double lat0t = proj->getLat0(); 
		//std::cout << latpt << "   ";
		//std::cout << lonpt << "   ";
		//std::cout << lat0t << '\n';

                //Compute coordinates of all geographic points points in sample's projection and add to the list
                for ( unsigned int i = 0; i < pl_reference->size(); i++ )
                {
                        //Get cartographic pole
                        Point3DGeographic <T> cart_pole =  proj->getCartPole();

                        //Convert geographic point oblique position
                        const T lat_trans = CartTransformation::latToLatTrans ( ( *pl_reference ) [i], &cart_pole );
                        Point3DGeographic <T> p_oblique ( lat_trans, CartTransformation::lonToLonTrans ( ( *pl_reference ) [i], lat_trans, &cart_pole, ReversedDirection ) ) ;

                        //Add point in oblique position to the list
                        pl_oblique.push_back ( p_oblique );

                        //Create new cartographic point
                        nl_projected.push_back ( new Node3DCartesianProjected <T> ( CartTransformation::latLonToX ( & p_oblique, proj, print_exception ),
                                                 CartTransformation::latLonToY ( & p_oblique, proj, print_exception ), 0.0, 0.0, 0.0, 0.0, 0.0, 
                                                 TTissotIndikatrix <T> (), 0.0 ) );
                }

                //Compare shape of equator, meridian and north / south pole using turning function, similarity transformation: this is a heuristic throwing unperspective samples
                if ( ( analysis_parameters.perform_heuristic ) && ( checkSample ( &meridians, &parallels, nl_test, &nl_projected, &nl_transformed, analysis_parameters.heuristic_sensitivity_ratio ) ) ||
		     ( ! analysis_parameters.perform_heuristic ) )
                {
			//Clear transformed points
			nl_transformed.clear();

			//Remove duplicate elements from reference data set (projected points)
                        nl_projected.removeDuplicateElements ( nl_projected.begin(), nl_projected.end(), 
				sortPointsByX <Node3DCartesianProjected <T> *> (), isEqualPointByPlanarCoordinates <Node3DCartesianProjected <T> *> () );

                        //Both datasets do not contain the same number of points
                        if ( nl_test->size() != nl_projected.size() ) throw ErrorBadData ( "ErrorBadData: both datasets contain a different number of points. ", "Sample had been thrown..." );

			//Create containers
			TTransformationKeyHomothetic2D <T> key_helmert;
			typename TDevIndexPairs <T>::Type min_pairs_helmert, excl_pairs_helmert;

			//Create temporary containers for k-best fit points
			Container <Node3DCartesian <T> *> nl_test_best_helmert;
			Container <Node3DCartesianProjected <T> *> nl_projected_best_helmert;

                        //Find k-best fit transformation key using Helmert transformation
			Transformation2D::findOptimalTransformationKeyLTS ( nl_test, &nl_projected, &nl_test_best_helmert, &nl_projected_best_helmert, key_helmert, min_pairs_helmert, excl_pairs_helmert, analysis_parameters.identical_points_percentage_ratio );

			//Correct meridians and parallels: remove inappropriate points from points indices
			correctMeridiansAndParrallels <T> ( &meridians, &parallels, min_pairs_helmert );

			//Rearrange test faces
			Container <Face <T> *, NonDestructable > faces_test_best_helmert;
			rearrangeFaces( faces_test, &faces_test_best_helmert, min_pairs_helmert );
			
			//Compute Tissot indikatrix parameters only for perspective samples ( will be faster ) for homothetic and helmert transformations
                        if ( ( analysis_parameters.analysis_type.a_homt || analysis_parameters.analysis_type.a_helt ) && ( analysis_parameters.match_method == MatchTissotIndikatrix ) )
                        {
                                for ( unsigned int i = 0; i < min_pairs_helmert.size(); i++ )
                                {
                                        //Create Tissot structure
                                        TTissotIndikatrix <T> tiss;

                                        //Compute parameter of the Tissot indikatrix only for valid latitude, otherwise use implicit parameters
                                        const T LAT_LIMIT = 80.0, DERIV_STEP = 0.01;

                                        if ( ( pl_oblique[min_pairs_helmert[i].second].getLat() < LAT_LIMIT - ANGLE_ROUND_ERROR ) && 
					     ( pl_oblique[min_pairs_helmert[i].second].getLat() > -LAT_LIMIT + ANGLE_ROUND_ERROR ) )
                                        {
                                                tiss = CartDistortion::Tiss ( DERIV_STEP, &pl_oblique[min_pairs_helmert[i].second], proj, analysis_parameters.print_exceptions );
                                        }

                                        //Set Tissot indikatrix parameters for the point
                                        nl_projected_best_helmert[i]->setTiss ( tiss );
                                }
                        }

                        //Create new cartographic sample
                        Sample <T> sample ( proj->getProjectionName(), proj->getCartPole().getLat(), proj->getCartPole().getLon(), proj->getLat0() );

                        //Compute all cartometric analysis for the sample
                        if ( analysis_parameters.analysis_type.a_cnd )
                        {
                                analyzeSampleCrossNearestNeighbourDistance ( &sample, &nl_test_best_helmert, & nl_projected_best_helmert, &nl_transformed );
                        }

                        if ( analysis_parameters.analysis_type.a_homt )
                        {
                                analyzeSampleHomotheticTransformationDeviation ( &sample, &nl_test_best_helmert, &nl_projected_best_helmert, &nl_transformed, analysis_parameters.match_method );
                        }

                        if ( analysis_parameters.analysis_type.a_helt )
                        {
                                analyzeSampleHelmertTransformationDeviation ( &sample, &nl_test_best_helmert, &nl_projected_best_helmert, &nl_transformed, analysis_parameters.match_method );
                        }

                        if ( analysis_parameters.analysis_type.a_gn_tf )
                        {
                                analyzeSampleGeographicNetworkTurningFunctionRatio ( &sample, &nl_test_best_helmert, &nl_projected_best_helmert, &meridians, &parallels );
                        }

                        if ( analysis_parameters.analysis_type.a_vd_tf )
                        {
                                analyzeSampleUsingVoronoiDiagramTurningFunctionRatio ( &sample, &nl_test_best_helmert, &nl_projected_best_helmert, &faces_test_best_helmert, analysis_parameters.analysis_type, print_exception );
                        }

                        //All analysis successful, add sample to the samples list
                        sl->push_back ( sample );

                        //Increment successfully created samples for projection
                        total_created_and_analyzed_samples_projection ++;
                }
        }

        // Unspecified error: math error(point or Tissot indikatrix could not be computed, analysis problem)
        // or parse equation error (could not parse coordinate functions)
        catch ( Error & error )
        {
                if ( print_exception )
                {
                        //Print error and info about projection properties
                        error.printException ( output );
                        *output << "proj = " << proj->getProjectionName() << "  latp = " << proj->getCartPole().getLat() << "  lonp = " << proj->getCartPole().getLon() << "  lat0 = " << proj->getLat0() << '\n';
                }
        }
}


template <typename T>
bool CartAnalysis::checkSample ( const typename TMeridiansList <T> ::Type * meridians, const typename TParallelsList <T> ::Type * parallels, const Container <Node3DCartesian <T> *> *nl_test, const Container <Node3DCartesianProjected <T> *> *nl_projected, Container <Node3DCartesian <T> *> *nl_transformed,
                                 const T heuristic_sensitivity_ratio )
{
        //Small heuristic for sample: compare shape or the prime meridian, equator (central meridian, central parallel) north pole and south pole for test and reference points
        //using turning function und analyze Helmert transformation (fast match using circles)
        const T TURNING_FUNCTION_MAX_DIFFERENCE = 1.0;
        const T MATCHING_FACTOR = 0.75;
        bool prime_meridian_found = false, equator_found = false;

        //Analyze match ratio using Helmert transformation ( additional test if no meridian and parallel have been found )
        TTransformationKeyHelmert2D <T> key_helmert;
        HelmertTransformation2D::transformPoints ( nl_projected, nl_test, nl_transformed, key_helmert );

        //Test match ratio: at least 50 percent of points matched (fast test with the circle)
        TIndexList matched_points;

        if ( Transformation2D::getMatchRatioCircle ( nl_projected, nl_transformed, matched_points, CollectOff, MATCHING_FACTOR * heuristic_sensitivity_ratio )  < 50 )
        {
                return false;
        }

        //Process all meridians and find prime meridian
        for ( typename TMeridiansList <T> ::Type::const_iterator i_meridians = meridians->begin(); i_meridians != meridians->end(); ++ i_meridians )
        {
                //Find prime meridian
                if ( ( *i_meridians ).getLongitude() == 0 )
                {
                        //Convert test meridian to Points 2D list
                        Container <Point3DCartesian <T> > pl_meridian_test ( nl_test, & ( ( * i_meridians ).getMeridianPointsIndices () ) );

                        //Convert projected meridian to Points2D list
                        Container <Point3DCartesian <T> > pl_meridian_projected ( nl_projected,  & ( ( * i_meridians ).getMeridianPointsIndices () ) );

                        //Compute turning function difference for each test and projected meridian
                        T turning_function_ratio_prime_meridian = TurningFunction::compare2PolyLinesUsingTurningFunction ( &pl_meridian_test, &pl_meridian_projected, RotationDependent, ScaleInvariant );

                        //Both prime meridians are not similar
                        if ( turning_function_ratio_prime_meridian > TURNING_FUNCTION_MAX_DIFFERENCE * pl_meridian_projected.size() * heuristic_sensitivity_ratio )
                        {
                                return false;
                        }

                        //Set prime meridian as found
                        prime_meridian_found = true;
                }
        }

        //Process all parallels find equator, north pole, south pole
        for ( typename TParallelsList <T> ::Type::const_iterator i_parallels = parallels->begin(); i_parallels != parallels->end(); ++ i_parallels )
        {
                //Find equator
                if ( ( *i_parallels ).getLatitude() == 0 )
                {
                        //Convert test equator to Points2D list
                        Container <Point3DCartesian <T> > pl_parallel_test ( nl_test, & ( ( * i_parallels ).getParallelPointsIndices () ) );

                        //Convert projected equator to Points2D list
                        Container <Point3DCartesian <T> > pl_parallel_projected ( nl_projected,  & ( ( * i_parallels ).getParallelPointsIndices () ) );

                        //Compute turning function difference for each parallel
                        T turning_function_ratio_equator = TurningFunction::compare2PolyLinesUsingTurningFunction ( &pl_parallel_test, &pl_parallel_projected, RotationDependent, ScaleInvariant );

                        //Both equators are not similar
                        if ( turning_function_ratio_equator > TURNING_FUNCTION_MAX_DIFFERENCE * pl_parallel_projected.size() * heuristic_sensitivity_ratio )
                        {
                                return false;
                        }

                        //Set equator as found
                        equator_found = true;
                }

                //Find and analyze north pole
                if ( ( *i_parallels ).getLatitude() == 90 )
                {
                        //Convert test parallel to Points2D list
                        Container <Point3DCartesian <T> > pl_parallel_test ( nl_test, & ( ( * i_parallels ).getParallelPointsIndices () ) );

                        //Convert projected parallel to Points2D list
                        Container <Point3DCartesian <T> > pl_parallel_projected ( nl_projected,  & ( ( * i_parallels ).getParallelPointsIndices () ) );

                        //Compute turning function difference for each parallel
                        T turning_function_ratio_north_pole = TurningFunction::compare2PolyLinesUsingTurningFunction ( &pl_parallel_test, &pl_parallel_projected, RotationDependent, ScaleInvariant );

                        //Both north poles are not similar
                        if ( turning_function_ratio_north_pole > TURNING_FUNCTION_MAX_DIFFERENCE * pl_parallel_projected.size() * heuristic_sensitivity_ratio )
                        {
                                return false;
                        }
                }

                //Find and analyze south pole
                if ( ( *i_parallels ).getLatitude() == -90 )
                {
                        //Convert test parallel to Points2D list
                        Container <Point3DCartesian <T> > pl_parallel_test ( nl_test, & ( ( * i_parallels ).getParallelPointsIndices () ) );

                        //Convert projected parallel to Points2D list
                        Container <Point3DCartesian <T> > pl_parallel_projected ( nl_projected,  & ( ( * i_parallels ).getParallelPointsIndices () ) );

                        //Compute turning function difference for each parallel
                        T turning_function_ratio_south_pole = TurningFunction::compare2PolyLinesUsingTurningFunction ( &pl_parallel_test, &pl_parallel_projected, RotationDependent, ScaleInvariant );

                        //Both south poles are not similar
                        if ( turning_function_ratio_south_pole > TURNING_FUNCTION_MAX_DIFFERENCE * pl_parallel_projected.size() * heuristic_sensitivity_ratio )
                        {
                                return false;
                        }
                }
        }

        //If not prime meridian found, continue with the found central meridian of the analyzed area
        if ( ( !prime_meridian_found ) && ( meridians->size() > 0 ) )
        {
                //Set central meridian of the dataset
                typename TMeridiansList <T> ::Type::const_iterator i_meridians = meridians->begin();

                for ( unsigned int i = 0; i < meridians->size() / 2; ++ i_meridians, ++ i ) {}

                //Convert test meridian to Points 2D list
                Container <Point3DCartesian <T> > pl_meridian_test ( nl_test, & ( ( *i_meridians ).getMeridianPointsIndices () ) );

                //Convert projected meridian to Points2D list
                Container <Point3DCartesian <T> > pl_meridian_projected ( nl_projected,  & ( ( *i_meridians ).getMeridianPointsIndices () ) );

                //Compute turning function difference for each test and projected meridian
                T turning_function_ratio_meridian = TurningFunction::compare2PolyLinesUsingTurningFunction ( &pl_meridian_test, &pl_meridian_projected, RotationDependent, ScaleInvariant );

                //Both prime meridians are not similar
                if ( turning_function_ratio_meridian > TURNING_FUNCTION_MAX_DIFFERENCE * pl_meridian_projected.size() * heuristic_sensitivity_ratio )
                {
                        return false;
                }
        }

        //If not equator found, continue with the found central parallel of the analyzed area
        if ( ( !equator_found ) && ( parallels->size() > 0 ) )
        {
                //Set central parallel of the dataset
                typename TParallelsList <T> ::Type::const_iterator i_parallels = parallels->begin();

                for ( unsigned int i = 0; i < parallels->size() / 2; ++ i_parallels, ++ i ) {}

                //Convert test parallel to Points2D list
                Container <Point3DCartesian <T> > pl_parallel_test ( nl_test, & ( ( *i_parallels ).getParallelPointsIndices () ) );

                //Convert projected parallel to Points2D list
                Container <Point3DCartesian <T> > pl_parallel_projected ( nl_projected,  & ( ( *i_parallels ).getParallelPointsIndices () ) );

                //Compute turning function difference for each parallel
                T turning_function_ratio_parallel = TurningFunction::compare2PolyLinesUsingTurningFunction ( &pl_parallel_test, &pl_parallel_projected, RotationDependent, ScaleInvariant );

                //Both equators are not similar
                if ( turning_function_ratio_parallel >  TURNING_FUNCTION_MAX_DIFFERENCE * pl_parallel_projected.size() * heuristic_sensitivity_ratio )
                {
                        return false;
                }
        }

        //All test successfull, sample may be perspective
        return true;
}


template <typename T>
void CartAnalysis::correctMeridiansAndParrallels ( typename TMeridiansList <T> ::Type * meridians, typename TParallelsList <T> ::Type * parallels,  
	typename TDevIndexPairs<T>::Type & point_pairs )
{
	//Process meridians and paralles: remove inappropriate points
	
	//Process all meridians
	for ( typename TMeridiansList <T> ::Type::iterator i_meridians = meridians->begin(); i_meridians != meridians->end(); )
        {
		//Get points of the meridian: break invariant
                TIndexList *meridian_points =  & const_cast <TIndexList &> ( ( *i_meridians ).getMeridianPointsIndices() );
                
                //Compare meridian points with list of pairs: remove indices of points missing in the list of pairs
                meridian_points->erase ( std::remove_if( meridian_points->begin(), meridian_points->end(), 
			removeUnequalMeridianParallelPointIndices <T> ( &point_pairs ) ), meridian_points->end() );
                
		//Transform all indices of points from all points list to new points list
		std::transform( meridian_points->begin(), meridian_points->end(), meridian_points->begin(), findMeridianParallelPointIndices <T> ( &point_pairs ) );

		 //Not enough points, erase meridian from set
		if ( meridian_points->size() < RANSAC_MIN_LINE_POINTS )
		{
			meridians->erase ( i_meridians++ );
			continue;
		}
                else ++i_meridians;
	}

	//Process all parallels
        for ( typename TParallelsList <T> ::Type::iterator i_parallels = parallels->begin(); i_parallels != parallels->end(); )
        {
		//Get points of the parallel: break invariant
                TIndexList *parallel_points  = & const_cast <TIndexList &> ( ( *i_parallels ).getParallelPointsIndices() );

		//Compare parallel points with list of pairs: emove indices of points missing in the list of pairs
                parallel_points->erase ( std::remove_if( parallel_points->begin(), parallel_points->end(), 
			removeUnequalMeridianParallelPointIndices <T> ( &point_pairs ) ), parallel_points->end() );
                
                //Transform all indices of points from all points list to new points list
		std::transform( parallel_points->begin(), parallel_points->end(), parallel_points->begin(), findMeridianParallelPointIndices <T> ( &point_pairs ) );

		//Not enough points, erase parallel from set
		if ( parallel_points->size() < RANSAC_MIN_LINE_POINTS )
		{
			parallels->erase ( i_parallels ++ );
			continue;
		}
                else ++i_parallels;
	}
}



template <typename T, TDestructable destructable>
void CartAnalysis::rearrangeFaces ( const Container <Face <T> *> *source_faces, Container <Face <T> *, destructable> *dest_faces, const typename TDevIndexPairs <T>::Type &min_pairs )
{
	//Rearrange faces of the test dataset, only faces belonging to k-best items will be added
	for (unsigned int i = 0; i < min_pairs.size(); i++ )
	{
		dest_faces->push_back( (*source_faces)[min_pairs[i].second] );
	}
}
                                                                                                                                                                                                                    //Each sample analysis
template <typename T>
void CartAnalysis::analyzeSampleCrossNearestNeighbourDistance ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                Container <Node3DCartesian <T> *> *nl_transformed )
{
        //Analyze all samples using cross nearest distance ratio
        try
        {
                //Clear list
                if ( nl_transformed->size() != 0 ) nl_transformed->clear();

                //Compute homothetic transformation
                TTransformationKeyHomothetic2D <T> key_homothetic;

                HomotheticTransformation2D::transformPoints ( nl_projected, nl_test, nl_transformed, key_homothetic );

                //Compute cross nearest distance ratio
                T cross_nearest_neighbour_distance_ratio = NNDistance::getCrossNearestNeighbourDistance ( nl_projected, nl_transformed );

                //Set ratio for the sample
                s->setCrossNearestNeighbourDistanceRatio ( cross_nearest_neighbour_distance_ratio );
        }

        //Throw exception
        catch ( Error & error )
        {
                s->setCrossNearestNeighbourDistanceRatio ( -1 );
                s->setCrossNearestNeighbourDistanceRatioPosition ( -1 );
        }
}

/*
template <typename T>
void CartAnalysis::analyzeSampleAverageNearestNeighbourDistance ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test, const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                Container <Node3DCartesian <T> *> *nl_transformed )
{
        //Analyze all samples using average nearest neighbour distance ratio
        try
        {
                //Clear list
                if ( nl_transformed->size() != 0 ) nl_transformed->clear();

                //Compute homothetic transformation
                if ( nl_transformed->size() == 0 )
                {
                        HomotheticTransformation2D::transformPoints ( nl_projected, nl_test, nl_transformed );
                }

                //Compute average nearest distance ratio
                T average_nearest_neighbour_distance_ratio = NNDistance::compare2DatasetsUsingAverageNearestNeighbourDistance ( nl_projected, nl_transformed );

                //Set ratio for the sample
                s->setAverageNearestNeighbourDistanceRatio ( average_nearest_neighbour_distance_ratio );
        }

        //Throw exception
        catch ( Error & error )
        {
                s->setAverageNearestNeighbourDistanceRatio ( -1 );
                s->setAverageNearestNeighbourDistanceRatioPosition ( -1 );
        }
}
*/

template <typename T>
void CartAnalysis::analyzeSampleHomotheticTransformationDeviation ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                Container <Node3DCartesian <T> *> *nl_transformed, TMatchPointsType & match_type )
{
        //Analyze sample using Homothetic transformation deviation
        try
        {
                //Clear list
                if ( nl_transformed->size() != 0 ) nl_transformed->clear();

                //Compute homothetic transformation
                TTransformationKeyHomothetic2D <T> key_homothetic;

                HomotheticTransformation2D::transformPoints ( nl_projected, nl_test, nl_transformed, key_homothetic );

                //Compute ratio and percentage match
                TIndexList matched_points;
                TDeviations <T> deviations = Transformation2D::getStandardDeviation ( nl_projected, nl_transformed );
                T homothetic_transformation_ratio = deviations.standard_deviation;
                T homothetic_transformation_perc_match = ( match_type == MatchCircle ? Transformation2D::getMatchRatioCircle ( nl_projected, nl_transformed, matched_points, CollectOn ) :
                                Transformation2D::getMatchRatioTissotIndikatrix ( nl_projected, nl_transformed, matched_points, CollectOn ) );
                
		//Set ratio and percentage match for the sample
                s->setHomotheticTransformationRatio ( homothetic_transformation_ratio );
                s->setHomotheticTransformationPercMatch ( homothetic_transformation_perc_match );
                s->setHomotheticTransformationMatchedPointNumbers ( matched_points );
        }

        //Throw exception
        catch ( Error & error )
        {
                s->setHomotheticTransformationRatio ( -1 );
                s->setHomotheticTransformationPercMatch ( -1 );
                s->setHomotheticTransformationRatioPosition ( -1 );
        }
}


template <typename T>
void CartAnalysis::analyzeSampleHelmertTransformationDeviation ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                Container <Node3DCartesian <T> *> *nl_transformed, TMatchPointsType & match_type )
{
        //Analyze sample using Helmert transformation deviation
        try
        {
                //Clear list
                if ( nl_transformed->size() != 0 ) nl_transformed->clear();

                //Compute Helmert transformation
                TTransformationKeyHelmert2D <T> key_helmert;

                HelmertTransformation2D::transformPoints ( nl_projected, nl_test, nl_transformed, key_helmert );

                //Compute ratio and percentage match
                TIndexList matched_points;
                TDeviations <T> deviations = Transformation2D::getStandardDeviation ( nl_projected, nl_transformed );
                T helmert_transformation_ratio = deviations.standard_deviation;
                T helmert_transformation_perc_match = ( match_type == MatchCircle  ? Transformation2D::getMatchRatioCircle ( nl_projected, nl_transformed, matched_points, CollectOn ) :
                                                        Transformation2D::getMatchRatioTissotIndikatrix ( nl_projected, nl_transformed, matched_points, CollectOn ) );

                //Set ratio and percentage match for the sample
                s->setHelmertTransformationRatio ( helmert_transformation_ratio );
                s->setHelmertTransformationPercMatch ( helmert_transformation_perc_match );
                s->setHelmertTransformationMatchedPointNumbers ( matched_points );
        }

        //Throw exception
        catch ( Error & error )
        {
                s->setHelmertTransformationRatio ( -1 );
                s->setHelmertTransformationPercMatch ( -1 );
                s->setHelmertTransformationRatioPosition ( -1 );
        }
}

/*
template <typename T>
void CartAnalysis::analyzeSampleGeographicNetworkAngularDifference ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                const typename TMeridiansList <T> ::Type * meridians, const typename TParallelsList <T> ::Type * parallels )
{
        //Analyze sample using angular differences in geographic network
        T angular_difference_meridians = 0, angular_difference_parallels = 0;

        try
        {
                //Analyze meridians
                typename TMeridiansList <T> ::Type::const_iterator i_meridians = meridians->begin();

                //Process all meridians
                for ( i_meridians = meridians->begin(); i_meridians != meridians->end(); ++i_meridians )
                {
                        //Process all points of the meridian
                        for ( unsigned int i = 1; i < ( *i_meridians ).getPointsIndices ().size() - 1; i++ )
                        {
                                const unsigned int i1 = ( *i_meridians ).getPointsIndices () [i-1], i2 = ( *i_meridians ).getPointsIndices () [i], i3 = ( *i_meridians ).getPointsIndices () [i+1];

                                //Compute angles
                                const T angle_test = Angle3Points::getAngle3Points ( ( *nl_test ) [i1], ( *nl_test ) [i2], ( *nl_test ) [i3] );
                                const T angle_projected = Angle3Points::getAngle3Points ( ( *nl_projected ) [i1], ( *nl_projected ) [i2], ( *nl_projected ) [i3] );

                                //Compute differences
                                if ( angle_test + angle_projected != 0 )
                                {
                                        angular_difference_meridians += ( angle_test - angle_projected ) * ( angle_test - angle_projected ) / ( angle_test + angle_projected );
                                }
                        }
                }

                //Analyze parallels
                typename TParallelsList <T> ::Type::const_iterator i_parallels = parallels->begin();

                //Process all parallels
                for ( i_parallels = parallels->begin(); i_parallels != parallels->end(); ++i_parallels )
                {
                        //Process all points of the parallel
                        for ( unsigned int i = 1; i < ( *i_parallels ).getPointsIndices ().size() - 1; i++ )
                        {
                                const unsigned int i1 = ( *i_parallels ).getPointsIndices () [i-1], i2 = ( *i_parallels ).getPointsIndices () [i], i3 = ( *i_parallels ).getPointsIndices () [i+1];

                                //Compute angles
                                const T angle_test = Angle3Points::getAngle3Points ( ( *nl_test ) [i1], ( *nl_test ) [i2], ( *nl_test ) [i3] );
                                const T angle_projected = Angle3Points::getAngle3Points ( ( *nl_projected ) [i1], ( *nl_projected ) [i2], ( *nl_projected ) [i3] );

                                //Compute angular differences
                                if ( angle_test + angle_projected != 0 )
                                {
                                        angular_difference_parallels += ( angle_test - angle_projected ) * ( angle_test - angle_projected ) / ( angle_test + angle_projected );
                                }
                        }
                }

                //Set angular difference
                s->setAngularDifferenceRatio ( 100 * ( angular_difference_meridians + angular_difference_parallels ) );
        }

        //Throw exception
        catch ( Error & error )
        {
                s->setAngularDifferenceRatio ( -1 );
                s->setAngularDifferenceRatioPosition ( -1 );
        }
}
*/

template <typename T>
void CartAnalysis::analyzeSampleGeographicNetworkTurningFunctionRatio ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                const typename TMeridiansList <T> ::Type * meridians, const typename TParallelsList <T> ::Type * parallels )
{
        //Analyze sample using angular turning function differences in geographic network
        T turning_function_ratio_meridians = 0, turning_function_ratio_parallels = 0;

        try
        {
		//No meridian or parallel
		if ( ( meridians->size() == 0 ) && ( parallels->size() == 0) )
		{
			throw ErrorBadData ("ErrorBadData: no meridians and parallels. ", "Can not perform analysis of turning function." );
		}

                typename TMeridiansList <T> ::Type::const_iterator i_meridians = meridians->begin();

                //Process all meridians
                for ( i_meridians = meridians->begin(); i_meridians != meridians->end(); ++i_meridians )
                {
			TIndexList il = ( * i_meridians ).getMeridianPointsIndices () ;
                        //Convert test meridian to Points 2D list
                        Container <Point3DCartesian <T> > pl_meridian_test ( nl_test, & ( ( * i_meridians ).getMeridianPointsIndices () ) );

                        //Convert projected meridian to Points2D list
                        Container <Point3DCartesian <T> > pl_meridian_projected ( nl_projected,  & ( ( * i_meridians ).getMeridianPointsIndices () ) );

                        //Compute turning function difference for each test and projected meridian
                        turning_function_ratio_meridians += TurningFunction::compare2PolyLinesUsingTurningFunction ( &pl_meridian_test, &pl_meridian_projected, RotationDependent, ScaleInvariant );
                }

                typename TParallelsList <T> ::Type::const_iterator i_parallels = parallels->begin();

                //Process all parallels
                for ( i_parallels = parallels->begin(); i_parallels != parallels->end(); ++i_parallels )
                {
                        //Convert test meridian to Points2D list
                        Container <Point3DCartesian <T> > pl_parallel_test ( nl_test, & ( ( * i_parallels ).getParallelPointsIndices () ) );

                        //Convert projected meridian to Points2D list
                        Container <Point3DCartesian <T> > pl_parallel_projected ( nl_projected,  & ( ( * i_parallels ).getParallelPointsIndices () ) );

                        //Compute turning function difference for each parallel
                        turning_function_ratio_parallels += TurningFunction::compare2PolyLinesUsingTurningFunction ( &pl_parallel_test, &pl_parallel_projected, RotationDependent, ScaleInvariant );
                }

                //Set turning function ratio
                s->setGNTurningFunctionRatio ( turning_function_ratio_meridians  +  turning_function_ratio_parallels );
        }

        //Throw exception
        catch ( Error & error )
        {
                s->setGNTurningFunctionRatio ( -1 );
                s->setGNTurningFunctionRatioPosition ( -1 );
        }
}


/*
template <typename T>
void CartAnalysis::analyzeSampleKNNGraphRatio ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                const GraphM <T> &g_test, const unsigned int k, const bool print_exception )
{
        //Analyze sample using 8 nearest neighbours graph ratio (X quadrat)
        try
        {
                //Create KNN graph for the second dataset
                GraphM <T> g_projected ( nl_projected->size() );
                GraphAlgorithms::createKNNGraph ( nl_projected, k, g_projected );

                //Compute ratio
                T knn_graph_ratio = 0;

                for ( unsigned int i = 0; i < nl_test->size(); i++ )
                {
                        for ( unsigned int j = 0; j < nl_test->size(); j++ )
                        {
                                if ( g_test.getW() ( i, j ) + g_projected.getW() ( i, j ) != 0 )
                                {
                                        knn_graph_ratio +=	( g_test.getW() ( i, j ) - g_projected.getW() ( i, j ) ) * ( g_test.getW() ( i, j ) - g_projected.getW() ( i, j ) ) /
                                                                ( g_test.getW() ( i, j ) + g_projected.getW() ( i, j ) ) ;
                                }
                        }
                }

                //Set ratio for the sample
                s->setKNNGraphRatio ( knn_graph_ratio );
        }

        //Throw exception
        catch ( Error & error )
        {
                s->setKNNGraphRatio ( -1 );
                s->setKNNGraphRatioPosition ( -1 );
        }
}
*/

/*
template <typename T>
void CartAnalysis::analyzeSampleNNNGraphRatio ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test,  const Container <Node3DCartesianProjected  <T> *> *nl_projected,
                const GraphM <T> &g_test, TAnalysisParameters <T>::TAnalysisType & analysis_type, const bool print_exception )
{
        //Analyze sample using natural nearest neighbours graph ratio (X quadrat)
        try
        {
                //Create NNN graph for the second dataset
                GraphM <T> g_projected ( nl_projected->size() );
                GraphAlgorithms::createNNNGraph ( nl_projected, g_projected );

                //Compute NNN graph ratio
                T nnn_graph_ratio = 0, sum_v_test = 0, sum_v_proj = 0;

                for ( unsigned int i = 0; i < nl_test->size(); i++ )
                {
                        for ( unsigned int j = 0; j < nl_test->size(); j++ )
                        {
                                if ( g_test.getW() ( i, j ) + g_projected.getW() ( i, j ) != 0 )
                                {
                                        nnn_graph_ratio +=	( g_test.getW() ( i, j ) - g_projected.getW() ( i, j ) ) * ( g_test.getW() ( i, j ) - g_projected.getW() ( i, j ) ) /
                                                                ( g_test.getW() ( i, j ) + g_projected.getW() ( i, j ) ) ;
                                }

                                //Compute sums
                                sum_v_test += g_test.getV() ( i, j );
                                sum_v_proj += g_projected.getV() ( i, j );
                        }
                }

                //Throw exception
                if ( ( sum_v_test == 0 ) || ( sum_v_proj == 0 ) )
                {
                        if ( sum_v_test == 0 ) analysis_type.a_nnng = false;

                        throw ErrorBadData ( "ErrorBadData: can not compute NNN graph analysis_type, ", "not enough bounded cells." );
                }

                //Set ratio for the sample
                s->setNNNGraphRatio ( nnn_graph_ratio );
        }

        //Throw exception
        catch ( Error & error )
        {
                //Do not compute analysis
                s->setNNNGraphRatio ( -1 );
                s->setNNNGraphRatioPosition ( -1 );
        }
}
*/

/*
template <typename T>
void CartAnalysis::analyzeSampleSphereOfInfulenceGraphRatio ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test, const  Container <Node3DCartesianProjected  <T> *> *nl_projected,
                const GraphM <T> &g_test, TAnalysisParameters <T>::TAnalysisType & analysis_type, const bool print_exception )
{
        //Analyze sample using four Sphere of Influence graph ratio (neighbour matrix difference)
        try
        {
                //Create Sphere of Influence graph fot the second dataset
                GraphM <T> g_projected ( nl_projected->size() );
                GraphAlgorithms::createSphereOfInfulenceGraph ( nl_projected, g_projected );

                //Compute ratio
                T sphere_of_influence_graph_ratio = 0, sum_v_test = 0, sum_v_proj = 0;

                for ( unsigned int i = 0; i < nl_test->size(); i++ )
                {
                        for ( unsigned int j = 0; j < nl_test->size(); j++ )
                        {
                                if ( g_test.getW() ( i, j ) + g_projected.getW() ( i, j ) != 0 )
                                {
                                        sphere_of_influence_graph_ratio +=	( g_test.getW() ( i, j ) - g_projected.getW() ( i, j ) ) * ( g_test.getW() ( i, j ) - g_projected.getW() ( i, j ) ) /
                                                                                ( g_test.getW() ( i, j ) + g_projected.getW() ( i, j ) ) ;
                                }

                                //Compute sums
                                sum_v_test += g_test.getV() ( i, j );
                                sum_v_proj += g_projected.getV() ( i, j );
                        }
                }

                //Throw exception
                if ( ( sum_v_test == 0 ) || ( sum_v_proj == 0 ) )
                {
                        if ( sum_v_test == 0 ) analysis_type.a_sig = false;

                        throw ErrorBadData ( "ErrorBadData: can not compute Sphere of influence graph analysis_type, ", "not enough bounded cells." );
                }

                //Set ratio for the sample
                s->setSphereOfInfluenceGraphRatio ( sphere_of_influence_graph_ratio );

        }

        //Throw exception
        catch ( Error & error )
        {
                s->setSphereOfInfluenceGraphRatio ( -1 );
                s->setSphereOfInfluenceGraphRatioPosition ( -1 );
        }
}
*/

template <typename T, TDestructable destructable>
void CartAnalysis::analyzeSampleUsingVoronoiDiagramTurningFunctionRatio ( Sample <T> *s, const Container <Node3DCartesian <T> *> *nl_test, const Container <Node3DCartesianProjected  <T> *> *nl_projected, const Container <Face <T> *, destructable> *faces_test,
                typename TAnalysisParameters<T>::TAnalysisType & analysis_type, const bool print_exception, std::ostream * output )
{
        //Analyze sample using Voronoi diagram ratios
        try
        {
                //Are there enough merged faces (merged Voronoi cells) ?
                if ( faces_test->size() < MIN_BOUNDED_VORONOI_CELLS )
                {
                        //Disable analysis
                        analysis_type.a_vd_tf = false;

                        //Stop analysis
                        return;
                }

                //Voronoi diagram of the reference dataset, data structures
                Container <HalfEdge <T> *> hl_dt_reference, hl_vor_reference, hl_merge_reference;
                Container <Node3DCartesian <T> *> nl_vor_reference, intersections_reference;
                Container <VoronoiCell <T> *> vor_cells_list_reference;

                //Create Voronoi diagram for the reference dataset
                Voronoi2D::VD ( ( Container <Node3DCartesian <T> *> * ) nl_projected, &nl_vor_reference, &hl_dt_reference, &hl_vor_reference, &vor_cells_list_reference, AppropriateBoundedCells, TopologicApproach, 0, print_exception, output );

                //Get total unbounded cells for the test dataset
                unsigned int total_bounded_pairs_of_cell = 0;

                //Initialize ratio
                T turning_function_difference = 0;

                for ( unsigned int index_faces = 0; index_faces < faces_test->size(); index_faces++ )
                {
                        //An appropriate face in the test dataset exists
                        if ( ( *faces_test)[index_faces] != NULL )
                        {
				//Get Voronoi cells for reference dataset
		                VoronoiCell <T> *vor_cell_reference = dynamic_cast < VoronoiCell <T> * > ( ( * nl_projected )[index_faces] -> getFace() );
	
                                //Bounded Voronoi cell for the reference dataset exists
                                if ( ( vor_cell_reference != NULL ) && ( vor_cell_reference->getBounded() ) )
                                {
                                        //Pointer to merged reference face
                                        Face <T> * face_reference = NULL;

                                        //Merge reference cell with adjacent cells
                                        Voronoi2D::mergeVoronoiCellAndAdjacentCells ( vor_cell_reference, &face_reference, &intersections_reference, &hl_merge_reference );

                                        //Count unbounded pairs of Voronoi cells
                                        total_bounded_pairs_of_cell ++;
					
					//std::cout << index_faces << '\n';
					//( * faces_test ) [index_faces]->print(output);
					//face_reference->print(output);

                                        //Compute turning function difference for both merged faces
                                        if ( analysis_type.a_vd_tf ) turning_function_difference +=  TurningFunction::compare2FacesUsingTurningFunction ( ( * faces_test ) [index_faces] , face_reference, RotationDependent, ScaleInvariant );

					std::cout << turning_function_difference << '\t';

                                        //Delete merged face
                                        if ( face_reference != NULL ) delete face_reference;
                                }
                        }
                }

                //Not enough corresponding pairs of bounded Voronoi cells suitable for analysis
                if ( total_bounded_pairs_of_cell < MIN_BOUNDED_VORONOI_CELLS )
                {
                        throw ErrorBadData ( "ErrorBadData: not enough unbounded pairs, ", "set values" );
                }

                //Set results of the analysis
                if ( analysis_type.a_vd_tf ) s->setVoronoiCellTurningFunctionRatio ( sqrt ( turning_function_difference / total_bounded_pairs_of_cell ) );
        }

        //Error while sample processed or invalid configuration for cell by cell ratia
        catch ( Error & error )
        {
                //Do not compute other analysis
                if ( analysis_type.a_vd_tf )
                {
                        s->setVoronoiCellTurningFunctionRatio ( -1 );
                        s->setVoronoiCellTurningFunctionRatioPosition ( -1 );
                }
        }
}



template <typename T>
void CartAnalysis::sortSamplesByComputedRatios ( Container <Sample <T> > *sl, const typename TAnalysisParameters<T>::TAnalysisType & analysis_type )
{

        //Sort results: Cross nearest distance
        if ( analysis_type.a_cnd )
                std::sort ( sl->begin(), sl->end(), sortSamplesByCrossNearestNeighbourDistanceRatio () );

		typename TAnalysisParameters <T>::TAnalysisType a1 ( analysis_type.a_cnd, 0, 0, 0, 0 ) ;
		setPositionForSortedSamples ( sl, a1 );

		//Sort results: Homothetic transformation, standard deviation + match function
        if ( analysis_type.a_homt )
                std::sort ( sl->begin(), sl->end(), sortSamplesByHomotheticTransformationRatio () );

		typename TAnalysisParameters <T>::TAnalysisType a2 ( 0, analysis_type.a_homt, 0, 0, 0 );
		setPositionForSortedSamples ( sl, a2 );

        //Sort results: Helmert transformation, standard deviation + match function
        if ( analysis_type.a_helt )
                std::sort ( sl->begin(), sl->end(), sortSamplesByHelmertTransformationRatio () );

		typename TAnalysisParameters <T>::TAnalysisType a3 ( 0, 0, analysis_type.a_helt, 0, 0 );
		setPositionForSortedSamples ( sl, a3 );

        //Sort results: geographic network turning function difference ratio
        if ( analysis_type.a_gn_tf )
                std::sort ( sl->begin(), sl->end(), sortSamplesByGNTurningFunctionRatio() );

		typename TAnalysisParameters <T>::TAnalysisType a4 ( 0, 0, 0, analysis_type.a_gn_tf, 0 );
		setPositionForSortedSamples ( sl, a4 );

        //Sort results: Voronoi cell Turning Function Ratio
        if ( analysis_type.a_vd_tf )
                std::sort ( sl->begin(), sl->end(), sortSamplesByVoronoiCellTurningFunctionRatio() );

		typename TAnalysisParameters <T>::TAnalysisType a5 ( 0, 0, 0, 0, analysis_type.a_vd_tf );
		setPositionForSortedSamples ( sl, a5 );

		//Sort samples by all ratios: result = arithmetic mean
        std::sort ( sl->begin(), sl->end(), sortSamplesByAllRatios <T> ( analysis_type ) );
}


template <typename T>
void CartAnalysis::setPositionForSortedSamples ( Container <Sample <T> > *sl, const typename TAnalysisParameters<T>::TAnalysisType & analysis_type )
{
        //Set position for each sample after its sorting
        unsigned int n = sl->size();

        for ( unsigned int i = 1; i < n; i++ )
        {
                //Cross nearest distance criterion
                if ( analysis_type.a_cnd )
                {
                        //Actual value differs from previous value: their difference > min value
                        if ( fabs ( ( *sl ) [i].getCrossNearestNeighbourDistanceRatio() -
                                        ( *sl ) [i - 1].getCrossNearestNeighbourDistanceRatio() ) > ARGUMENT_ROUND_ERROR )
                        {
                                //Previous value negative: first position
                                if ( ( *sl ) [i - 1].getCrossNearestNeighbourDistanceRatio() < 0 )
                                        ( *sl ) [i].setCrossNearestNeighbourDistanceRatioPosition ( 1 );

                                //Previous value positive: position = position + 1
                                else
                                        ( *sl ) [i].setCrossNearestNeighbourDistanceRatioPosition ( ( *sl ) [i - 1].getCrossNearestNeighbourDistanceRatioPosition() + 1 );
                        }

                        //Actual value same as the previous value: both values are equal
                        else
                        {
                                ( *sl ) [i].setCrossNearestNeighbourDistanceRatioPosition ( ( *sl ) [i - 1].getCrossNearestNeighbourDistanceRatioPosition() );
                        }
                }

                //Homothetic transformation, standard deviation criterion + match factor
                if ( analysis_type.a_homt )
                {
                        //Actual value differs from previous value: their difference > min value
                        if ( fabs ( ( *sl ) [i].getHomotheticTransformationRatio() -
                                        ( *sl ) [i - 1].getHomotheticTransformationRatio() ) > ARGUMENT_ROUND_ERROR )
                        {
                                //Previous value negative: first position
                                if ( ( *sl ) [i - 1].getHomotheticTransformationRatio() < 0 )
                                        ( *sl ) [i].setHomotheticTransformationRatioPosition ( 1 );

                                //Previous value positive: position = position + 1
                                else
                                        ( *sl ) [i].setHomotheticTransformationRatioPosition ( ( *sl ) [i - 1].getHomotheticTransformationRatioPosition() + 1 );
                        }

                        //Actual value same as the previous value: both values are equal
                        else
                        {
                                ( *sl ) [i].setHomotheticTransformationRatioPosition ( ( *sl ) [i - 1].getHomotheticTransformationRatioPosition() );
                        }
                }

                //Helmert transformation, standard deviation criterion + match factor
                if ( analysis_type.a_helt )
                {
                        //Actual value differs from previous value: their difference > min value
                        if ( fabs ( ( *sl ) [i].getHelmertTransformationRatio() -
                                        ( *sl ) [i - 1].getHelmertTransformationRatio() ) > ARGUMENT_ROUND_ERROR )
                        {
                                //Previous value negative: first position
                                if ( ( *sl ) [i - 1].getHelmertTransformationRatio() < 0 )
                                        ( *sl ) [i].setHelmertTransformationRatioPosition ( 1 );

                                //Previous value positive: position = position + 1
                                else
                                        ( *sl ) [i].setHelmertTransformationRatioPosition ( ( *sl ) [i - 1].getHelmertTransformationRatioPosition() + 1 );
                        }

                        //Actual value same as the previous value: both values are equal
                        else
                        {
                                ( *sl ) [i].setHelmertTransformationRatioPosition ( ( *sl ) [i - 1].getHelmertTransformationRatioPosition() );
                        }
                }

                //Turning function criterion for meridians and parallels
                else if ( analysis_type.a_gn_tf )
                {
                        //Actual value differs from previous value: their difference > min value
                        if ( fabs ( ( *sl ) [i].getGNTurningFunctionRatio() -
                                        ( *sl ) [i - 1].getGNTurningFunctionRatio() ) > ARGUMENT_ROUND_ERROR )
                        {
                                //Previous value negative: first position
                                if ( ( *sl ) [i - 1].getGNTurningFunctionRatio() < 0 )
                                        ( *sl ) [i].setGNTurningFunctionRatioPosition ( 1 );

                                //Previous value positive: position = position + 1
                                else
                                        ( *sl ) [i].setGNTurningFunctionRatioPosition ( ( *sl ) [i - 1].getGNTurningFunctionRatioPosition() + 1 );
                        }

                        //Actual value same as the previous value: both values are equal
                        else
                        {
                                ( *sl ) [i].setGNTurningFunctionRatioPosition ( ( *sl ) [i - 1].getGNTurningFunctionRatioPosition() );
                        }
                }

                //Voronoi cell turning function criterion
                else if ( analysis_type.a_vd_tf )
                {
                        //Actual value differs from previous value: their difference > min value
                        if ( fabs ( ( *sl ) [i].getVoronoiCellTurningFunctionRatio() -
                                        ( *sl ) [i - 1].getVoronoiCellTurningFunctionRatio() ) > ARGUMENT_ROUND_ERROR )
                        {
                                //Previous value negative: position = 1
                                if ( ( *sl ) [i - 1].getVoronoiCellTurningFunctionRatio() < 0 )
                                        ( *sl ) [i].setVoronoiCellTurningFunctionRatioPosition ( 1 );

                                //Previous value positive: position = position + 1
                                else
                                        ( *sl ) [i].setVoronoiCellTurningFunctionRatioPosition ( ( *sl ) [i - 1].getVoronoiCellTurningFunctionRatioPosition() + 1 );
                        }

                        //Actual value same as the previous value: both values are equal
                        else
                        {
                                ( *sl ) [i].setVoronoiCellTurningFunctionRatioPosition ( ( *sl ) [i - 1].getVoronoiCellTurningFunctionRatioPosition() );
                        }
                }
        }
}


template <typename T>
void CartAnalysis::printResults ( const Container <Sample <T> > *sl, unsigned int items_printed, const TAnalysisParameters <T> & analysis_parameters, std::ostream * output )
{
        //Print first n items sorted by the similarity match ratio
        unsigned int n = sl->size();

        //Correct number of printed items
        if ( items_printed > n ) items_printed = n;

        //Some points were loaded
        if ( n > 0 )
        {
                //Table  1
                *output << "Results containg values of the criteria:" << std::endl << std::endl;

                //Set properties
                *output << std::showpoint << std::fixed << std::right;

                //Create header 1 : results of analalysis
                *output	<< std::setw ( 3 ) << "#"
                << std::setw ( 6 ) << "Proj"
                << std::setw ( 6 ) << "latP"
                << std::setw ( 6 ) << "lonP"
                << std::setw ( 6 ) << "lat0"
                << std::setw ( 9 ) << "CND"
                << std::setw ( 9 ) << "HOMT";

                //Print type of match
                analysis_parameters.match_method == MatchCircle ? *output << std::setw ( 5 ) << "+ MC" : *output << std::setw ( 5 ) << "+ MT";

                *output << std::setw ( 9 ) << "HELT";

                //Print type of match
                analysis_parameters.match_method == MatchCircle ? *output << std::setw ( 5 ) << "+ MC" : *output << std::setw ( 5 ) << "+ MT";

                *output << std::setw ( 9 ) << "GNTF"
                << std::setw ( 9 ) << "VDTF" << std::endl;

                //Values of the criterion for each projection
                for ( unsigned int i = 0;  i < ( analysis_parameters.analyzed_proj_index < 0 ? items_printed : n ); i++ )
                {
                        if ( analysis_parameters.analyzed_proj_index < 0 )
                        {
                                ( *sl ) [i].printSampleRatios ( output, i + 1, analysis_parameters.analysis_type );
                        }

                        else if ( ( * sl ) [i].getAnalyzedProjectionSample() )
                        {
                                ( *sl ) [i].printSampleRatios ( output, i + 1, analysis_parameters.analysis_type );
                                break;
                        }
                }

                //Table 2
                *output << std::endl << "Results containg positions of the criteria:" << std::endl << std::endl;

                //Create header 2: positions
                *output	<< std::setw ( 3 ) << "#"
                << std::setw ( 6 ) << "Proj"
                << std::setw ( 6 ) << "latP"
                << std::setw ( 6 ) << "lonP"
                << std::setw ( 6 ) << "lat0"
                << std::setw ( 6 ) << "CND"
                << std::setw ( 6 ) << "HOMT"
                << std::setw ( 6 ) << "HELT"
                << std::setw ( 6 ) << "GNTF"
                << std::setw ( 6 ) << "VDTF" << std::endl;

                //Positions of the criterion for each projection
                for ( unsigned int i = 0;  i < ( analysis_parameters.analyzed_proj_index < 0 ? items_printed : n ); i++ )
                {
                        if ( analysis_parameters.analyzed_proj_index < 0 )
                        {
                                ( *sl ) [i].printSamplePositions ( output, i + 1, analysis_parameters.analysis_type );
                        }

                        else if ( ( * sl ) [i].getAnalyzedProjectionSample() )
                        {
                                ( *sl ) [i].printSamplePositions ( output, i + 1, analysis_parameters.analysis_type );
                                break;
                        }
                }

                //Table 3
                *output << std::endl << "Matched points indices for each projection:" << std::endl << std::endl;

                //All matched points
                for ( unsigned int i = 0;  i < ( analysis_parameters.analyzed_proj_index < 0 ? items_printed : n ); i++ )
                {
                        if ( analysis_parameters.analyzed_proj_index < 0 )
                        {
                                ( *sl ) [i].printSampleMatchedPoints ( output, i + 1, analysis_parameters.analysis_type );
                        }

                        else if ( ( * sl ) [i].getAnalyzedProjectionSample() )
                        {
                                ( *sl ) [i].printSampleMatchedPoints ( output, i + 1, analysis_parameters.analysis_type );
                                break;
                        }
                }

                *output << std::endl;
                *output << std::endl;
        }
}


#endif
