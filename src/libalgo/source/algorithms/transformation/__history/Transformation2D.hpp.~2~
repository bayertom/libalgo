// Description: Several equations related to 2D transformation

// Copyright (c) 2010 - 2011
// Tomas Bayer
// Charles University in Prague, Faculty of Science
// bayertom@natur.cuni.cz

// This library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this library. If not, see <http://www.gnu.org/licenses/>.


#ifndef Transformation2D_HPP
#define Transformation2D_HPP

#include <cmath>
#include <ctime>

#include "libalgo/source/structures/list/IndexLists.h"

#include "libalgo/source/algorithms/eucldistance/EuclDistance.h"
#include "libalgo/source/algorithms/pointellipseposition/PointEllipsePosition.h"
#include "libalgo/source/algorithms/cartdistortion/CartDistortion.h"

#include "libalgo/source/comparators/sortPointsByX.h"
#include "libalgo/source/comparators/sortPointsByY.h"
#include "libalgo/source/comparators/sortPointPairsByDeviation.h"
#include "libalgo/source/comparators/sortPointPairsByIndices.h"


template <typename Point1, typename Point2, typename TKey>
void Transformation2D::findOptimalTransformationKeyLTS ( const Container <Point1 *> *global_points_source, const Container <Point2 *> *local_points_source,
                Container <Point1 *> *global_points_dest, Container <Point2 *> *local_points_dest, TKey & min_key, typename TDevIndexPairs <typename Point1::Type>::Type &min_pairs,
                typename TDevIndexPairs <typename Point1::Type>::Type &excl_pairs, const typename Point1::Type perc_ratio )
{
        //Find optimal transformation key using least trimmed squares
        const unsigned int n_global_points_source = global_points_source->size(),
                        n_iterations = 10 * n_global_points_source;

	//Throw exception: bad ratio
	if ( ( perc_ratio < 0.0 ) || ( perc_ratio > 1 ) )
	{
		throw ErrorBadData ( "ErrorBadData: bad perc ratio, perc ratio = ( 0, 1). ", "Can not find optimal transformation key." );
	}

        //Throw exception: not enough points
        if ( n_global_points_source * perc_ratio < 3 )
        {
                throw ErrorBadData ( "ErrorBadData: not enough global points to be optimized. ", "Can not find optimal transformation key." );
        }

        //Initialize min error
        typename Point1::Type min_error = MAX_FLOAT;

        //Initialize random number generator
        srand ( ( unsigned ) time ( 0 ) );

        //Perform n iterations to find the best key
	unsigned int i = 0;
	do
        {
                //Get 2 randomly generated different indices
                int index2 = 0;
                int index1 = rand() % n_global_points_source ;

                do
                {
                        index2 = rand() % n_global_points_source;
                } while ( index1 == index2 );

		//Create point pairs
		typename TDevIndexPairs <typename Point1::Type>::Type pairs;
		pairs.push_back ( std::make_pair ( 0.0, index1 ) );
		pairs.push_back ( std::make_pair ( 1.0, index2 ) );

                //Rearrange points: use only fist k-best points
                rearrangePoints ( global_points_source, local_points_source, global_points_dest, local_points_dest, pairs, perc_ratio );

                //Compute transformation using two points
                TKey key, actual_key;
                Container <Point2 *, NonDestructable> transformed_points;

                //Compute initial transformation for the key of 2 points
                getTransformKey ( global_points_dest, local_points_dest, actual_key );
                transform ( global_points_source, local_points_source, &transformed_points, actual_key );

                //Compute initial deviation
                TDeviations <typename Point1::Type> deviations = getStandardDeviation ( global_points_source, &transformed_points );

                //Initialize error
		typename Point1::Type error = MAX_FLOAT, actual_error = deviations.standard_deviation;

                //Performs iterations for this key
                do
                {
                        //Clear points and pairs
                        transformed_points.clear();
                        pairs.clear();

                        //Assign old values
                        error = actual_error;
                        key = actual_key;

                        //Create pairs and sort
                        processPairsOfPoints ( deviations, pairs, perc_ratio );

                        //Rearrange points: use only fist k-best points
                        rearrangePoints ( global_points_source, local_points_source, global_points_dest, local_points_dest, pairs, perc_ratio );

                        //Compute transformation from k-best points (k-best key)
                        getTransformKey ( global_points_dest, local_points_dest, actual_key );

                        //Compute transformation for all local points using k-best key
                        transform ( global_points_source, local_points_source, &transformed_points, actual_key );

                        //Get deviations between all global points and all transformed points from k-best key
                        deviations = getStandardDeviation ( global_points_source, &transformed_points );

                        //Clear transformed points
                        transformed_points.clear();

                        //Compute initial error
                        //actual_error = deviations.standard_deviation;
			
                        //Compute transformation for k_best local points using k-best key
                        getTransformKey ( global_points_dest, local_points_dest, key );
                        transform ( global_points_dest, local_points_dest, &transformed_points, key );

                        //Get deviations between k-best global points and k-best transformed points using k-best key
                        TDeviations <typename Point1::Type> deviations2 = getStandardDeviation ( global_points_dest, &transformed_points );

                        actual_error = deviations2.standard_deviation;
                        //std::cout << deviations2.standard_deviation << "  ";

                } while ( actual_error < error && perc_ratio != 1.0 );

                //We found a better key: remember deviation (error), key and pairs
                if ( error < min_error )
                {
                        min_error = error;
                        //std::cout << min_error << '\n';
                        min_key = key;
                        min_pairs = pairs;
                }

        } while ( ++i < n_iterations && perc_ratio != 1.0 );

	//Sort pairs points indices
	std::sort ( min_pairs.begin(), min_pairs.end(), sortPointPairsByIndices <typename Point1::Type> () );

        //Rearrange points: use only first k-best points
        rearrangePoints ( global_points_source, local_points_source, global_points_dest, local_points_dest, min_pairs, perc_ratio );
}


template <typename T>
void Transformation2D::processPairsOfPoints ( const TDeviations <T> &deviations, typename TDevIndexPairs <T>::Type & point_pairs, const float perc_ratio )
{
        //Create pairs of all points and sort by standard deviation
	const unsigned int n = deviations.mean_deviations.size();

        for ( unsigned int j = 0; j < n ; j++ )
        {
                point_pairs.push_back ( std::make_pair ( deviations.mean_deviations[j].dev_xy, j ) );
        }

        //Sort pairs by standard deviation
        std::sort ( point_pairs.begin(), point_pairs.end(), sortPointPairsByDeviation <T> () );
	
	//Let only first k-items
	point_pairs.erase ( point_pairs.begin() + n * perc_ratio, point_pairs.end() );
}


template <typename Point1, typename Point2>
void Transformation2D::rearrangePoints ( const Container <Point1 *> *global_source, const Container <Point2 *> *local_source, Container <Point1 *> *global_destination,
                Container <Point2 *> *local_destination, const typename TDevIndexPairs <typename Point1::Type> ::Type & pairs, const float perc_ratio )
{
        //Rearrange points from destination container using pair index
        const unsigned int n_global_points_source = global_source->size(),
                           k_pairs_best = pairs.size();

        //Clear containers
        global_destination->clear();
        local_destination->clear();

        //Process all k-best pairs
        for ( unsigned int j = 0; j < k_pairs_best; j++ )
        {
                //Get index
                const unsigned int index = pairs[j].second;

                //Throw exception
                if ( index >= n_global_points_source )
                {
                        throw ErrorIndexOutOfBound ( "ErrorIndexOutOfBound: point index > total points. ", "Can compute best transformation key." );
                }

                //Add k-best point to the list
                global_destination->push_back ( ( *global_source ) [index] ->clone() );
                local_destination->push_back ( ( *local_source ) [index] ->clone() );
        }
}


template <typename Point1, typename Point2, TDestructable destructable, TDestructable destructable2>
TDeviations <typename Point1::Type> Transformation2D::getStandardDeviation ( const Container <Point1 *, destructable> *global_points_source, const Container <Point2 *, destructable2> *transformed_points_dest )
{
        //Compute standard deviation of the triangulation using all global points
        typename Point1::Type deviation_root = 0;
        TDeviations <typename Point1::Type> deviations;

        //Total points
        const unsigned int n_global = global_points_source->size(),
                                      n_transformed = transformed_points_dest->size();

        //Different size of both lists
        if ( n_global != n_transformed )
        {
                throw ErrorBadData ( "ErrorBadData: can not compute standard deviation ( Helmert transformation ), ", "different size of local and global lists of points." );
        }

        //Compute deviations
        for ( unsigned int i = 0; i < n_global; i++ )
        {
                TMeanDeviation <typename Point1::Type> mean_deviation;

                //Compute mean deviations dev_x, dev_y
                mean_deviation.dev_x = ( *global_points_source ) [i] -> getX() - ( *transformed_points_dest ) [i] -> getX();
                mean_deviation.dev_y = ( *global_points_source ) [i] -> getY() - ( *transformed_points_dest ) [i] -> getY();
                mean_deviation.dev_xy = sqrt ( mean_deviation.dev_x * mean_deviation.dev_x +
                                               mean_deviation.dev_y * mean_deviation.dev_y );

                //Add to the list
                deviations.mean_deviations.push_back ( mean_deviation );

                //Compute root of deviations
                deviation_root += mean_deviation.dev_xy * mean_deviation.dev_xy;
        }

        //Compute standard deviation
        deviations.standard_deviation =  sqrt ( deviation_root / n_global );

        return deviations;
}


template <typename Point1, typename Point2>
typename Point1::Type Transformation2D::getMatchRatioCircle ( const Container <Point1 *> *global_points_source, const Container <Point2 *> *transformed_points_dest, TIndexList & matched_points,
                const TMatchedPointsCollectType collect_matched_points, const float lambda )
{
        //Compute match ratio: how many points is inside a circle?
        unsigned int total_points_matched = 0;
        const unsigned int n = global_points_source->size();

        //Get extreme coordinates
        const typename Point1::Type x_min = ( * ( std::min_element ( global_points_source->begin(), global_points_source->end(), sortPointsByX <Point1> () ) ) )->getX();
        const typename Point1::Type y_min = ( * ( std::min_element ( global_points_source->begin(), global_points_source->end(), sortPointsByY <Point1> () ) ) )->getY();
        const typename Point1::Type x_max = ( * ( std::max_element ( global_points_source->begin(), global_points_source->end(), sortPointsByX <Point1> () ) ) )->getX();
        const typename Point1::Type y_max = ( * ( std::max_element ( global_points_source->begin(), global_points_source->end(), sortPointsByY <Point1> () ) ) )->getY();

        //Compute radius of the circle: modified equation given by Wamelen et al (2001)
        const typename Point1::Type max_radius = 0.25 * lambda * max ( x_max - x_min, y_max - y_min ) / sqrt ( ( float ) n );

        //Find points satisfying the criterion d((x,y)trans, (x,y)) < min_error
        for ( unsigned int i = 0; i < n; i++ )
        {
                //Matching condition
                if ( EuclDistance::getEuclDistance2D ( ( *global_points_source ) [i]->getX(), ( *global_points_source ) [i]->getY(), ( *transformed_points_dest ) [i]->getX(), ( *transformed_points_dest ) [i]->getY() ) < max_radius )
                {
                        total_points_matched ++;

                        if ( collect_matched_points == CollectOn ) matched_points.push_back ( ( *global_points_source ) [i] ->getPointID() - ( *global_points_source ) [0] ->getPointID() );
                }
        }

        //Compute match ratio
        return ( 100.0 / n ) * total_points_matched;
}


template <typename Point1, typename Point2>
typename Point1::Type Transformation2D::getMatchRatioTissotIndikatrix ( const Container <Point1 *> *global_points_source, const Container <Point2 *> *transformed_points_dest, TIndexList & matched_points,
                const TMatchedPointsCollectType collect_matched_points, const float lambda )
{
        //Compute match ratio: how many points is inside a Tissot indikatrix?
        unsigned int total_points_matched = 0;
        const unsigned int n = global_points_source->size();

        //Get extreme coordinates
        const typename Point1::Type x_min = ( * ( std::min_element ( global_points_source->begin(), global_points_source->end(), sortPointsByX <Point1> () ) ) )->getX();
        const typename Point1::Type y_min = ( * ( std::min_element ( global_points_source->begin(), global_points_source->end(), sortPointsByY <Point1> () ) ) )->getY();
        const typename Point1::Type x_max = ( * ( std::max_element ( global_points_source->begin(), global_points_source->end(), sortPointsByX <Point1> () ) ) )->getX();
        const typename Point1::Type y_max = ( * ( std::max_element ( global_points_source->begin(), global_points_source->end(), sortPointsByY <Point1> () ) ) )->getY();

        //Compute radius of the circle: modified equation given by Wamelen et al (2001)
        const typename Point1::Type max_radius = 0.25 * lambda * max ( x_max - x_min, y_max - y_min ) / sqrt ( ( float ) n );

        //Find points satisfying the criterion d((x,y)trans, (x,y)) < min_error
        for ( unsigned int i = 0; i < n; i++ )
        {
                //Get Tissote indikatrix parameters
                const TTissotIndikatrix <typename Point1::Type> tiss = ( *global_points_source ) [i]->getTiss();

                double dist = ( EuclDistance::getEuclDistance2D ( ( *global_points_source ) [i]->getX(), ( *global_points_source ) [i]->getY(), ( *transformed_points_dest ) [i]->getX(), ( *transformed_points_dest ) [i]->getY() ) );

                //Matching condition
                if ( PointEllipsePosition::getPointEllipsePosition ( ( *transformed_points_dest ) [i], ( *global_points_source ) [i]->getX(), ( *global_points_source ) [i]->getY(), max_radius * tiss.a_tiss, max_radius * tiss.b_tiss, tiss.Ae_proj + tiss.b_mer - 90 ) )
                {
                        total_points_matched ++;

                        if ( collect_matched_points == CollectOn ) matched_points.push_back ( ( *global_points_source ) [i] ->getPointID() - ( *global_points_source ) [0] ->getPointID() );
                }
        }

        //Compute match ratio
        return ( 100.0 / n ) * total_points_matched;
}


template <typename Point1, typename Point2, typename Point3, TDestructable destructable, TDestructable destructable2, TDestructable destructable3>
void Transformation2D::transformPoints ( const Container <Point1 *, destructable> *global_points, const Container <Point2 *, destructable2> *local_points, Container <Point3 *, destructable3> *transformed_points,
                TTransformationKeyHelmert2D <typename Point1::Type> & key, const bool print_exception, std::ostream * output )
{
        //Compute Helmert transformation, overloaded function for Helmert key
        HelmertTransformation2D::transformPoints ( global_points, local_points, transformed_points, key );
}


template <typename Point1, typename Point2, typename Point3, TDestructable destructable, TDestructable destructable2, TDestructable destructable3>
void Transformation2D::transformPoints ( const Container <Point1 *, destructable> *global_points, const Container <Point2 *, destructable2> *local_points, Container <Point3 *, destructable3> *transformed_points,
                TTransformationKeyHomothetic2D <typename Point1::Type> & key, const bool print_exception, std::ostream * output )
{
        //Compute Homothetic transformation, overloaded function for Homothetic key
        HomotheticTransformation2D::transformPoints ( global_points, local_points, transformed_points, key );
}


template <typename Point1, typename Point2, TDestructable destructable, TDestructable destructable2>
void Transformation2D::getTransformKey ( const Container <Point1 *, destructable> *global_points, const Container <Point2 *, destructable2> *local_points, TTransformationKeyHelmert2D <typename Point1::Type> &key )
{
        //Compute Helmert transformation key, overloaded function for Helmert key
        HelmertTransformation2D::getTransformKey ( global_points, local_points, key );
}


template <typename Point1, typename Point2, TDestructable destructable, TDestructable destructable2>
void Transformation2D::getTransformKey ( const Container <Point1 *, destructable> *global_points, const Container <Point2 *, destructable2> *local_points, TTransformationKeyHomothetic2D <typename Point1::Type> &key )
{
        //Compute Homothetic transformation key, overloaded overloaded function for Homothetic key
        HomotheticTransformation2D::getTransformKey ( global_points, local_points, key );
}


template <typename Point1, typename Point2, typename Point3, TDestructable destructable, TDestructable destructable2, TDestructable destructable3>
void Transformation2D::transform ( const Container <Point1 *, destructable> *global_points, const Container <Point2 *, destructable2> *local_points, Container <Point3 *, destructable3> *transformed_points, const TTransformationKeyHelmert2D <typename Point1::Type> & key )
{
        //Transform points using Helmert transformation, overloaded overloaded function for Helmert key
        HelmertTransformation2D::transform ( global_points, local_points, transformed_points, key );
}


template <typename Point1, typename Point2, typename Point3, TDestructable destructable, TDestructable destructable2, TDestructable destructable3>
void Transformation2D::transform ( const Container <Point1 *, destructable> *global_points, const Container <Point2 *, destructable2> *local_points, Container <Point3 *, destructable3> *transformed_points, const TTransformationKeyHomothetic2D <typename Point1::Type> & key )
{
        //Transform points using Homothetic transformation, overloaded overloaded function for Homothetic key
        HomotheticTransformation2D::transform ( global_points, local_points, transformed_points, key );
}

#endif
